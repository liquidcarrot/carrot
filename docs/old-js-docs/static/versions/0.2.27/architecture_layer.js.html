<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Liquid Carrot - architecture/layer.js - Documentation</title>
    <link rel="shortcut icon" href="/liquid-carrot-favicon.png" />
    
    
    
    
    
    <meta property="og:title" content=""/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    
    <meta property="og:url" content=""/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="styles/bulma.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/ionicons/2.0.1/css/ionicons.min.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger">
  <div class="fixed-action-btn">
    <div class="button-floating">
      <!--
      <label for="nav-trigger" class="navicon-button x">
        <div class="navicon"></div>
      </label>
      -->
        <i class="ion-ios-book" aria-hidden="true"></i>
    </div>
  </div>
</label>
<label for="nav-trigger" class="overlay"></label>

<div class="navbar is-fixed-top" role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a class="navbar-item" href="#" style="padding:0">
      <img src="img/carrot-logo.png" height="28">
    </a>

    <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarBasicExample">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>

  <div id="navbarBasicExample" class="navbar-menu">
    <div class="navbar-start">
      <a class="navbar-item" href="/">Home</a>
      <a class="navbar-item" href="/carrot">Docs</a>
      <a class="navbar-item" href="https://github.com/liquidcarrot/carrot" target="_blank"><i class="ion-social-github" aria-hidden="true"></i></a>
      <div class="navbar-item has-dropdown is-hoverable">
        <a class="navbar-link">
          Versions
        </a>
        
        <div class="navbar-dropdown">
          <a href='https://liquidcarrot.io/carrot/versions/0.2.27/' class="navbar-item">v0.2.27</a>
      <a href='https://liquidcarrot.io/carrot/' class="navbar-item">latest</a>
        </div>
      </div>
      <div class="navbar-item has-dropdown is-hoverable">
        <a class="navbar-link">
          More
        </a>

        <div class="navbar-dropdown">
          <a class="navbar-item" href="mailto:people@liquidcarrot.io?subject=Contact%20From%20Docs">
            Contact
          </a>
          <hr class="navbar-divider">
          <a class="navbar-item" href="https://github.com/liquidcarrot/carrot/issues/new">
            Report an issue
          </a>
        </div>
      </div>
    </div>

    <div class="navbar-end">
      <div class="navbar-item">
        <input type="text" id="nav-search" placeholder="Search" autofocus>
      </div>
    </div>
  </div>
</div>

<nav >
    <h3>Classes</h3><ul><li><a href="Connection_.html">Connection</a><ul class='methods'><li data-type='method'><a href="Connection_.html#.innovationID">innovationID</a></li><li data-type='method'><a href="Connection_.html#.toJSON">toJSON</a></li></ul></li><li><a href="Group.html">Group</a><ul class='methods'><li data-type='method'><a href="Group.html#.activate">activate</a></li><li data-type='method'><a href="Group.html#.clear">clear</a></li><li data-type='method'><a href="Group.html#.connect">connect</a></li><li data-type='method'><a href="Group.html#.disconnect">disconnect</a></li><li data-type='method'><a href="Group.html#.gate">gate</a></li><li data-type='method'><a href="Group.html#.propagate">propagate</a></li><li data-type='method'><a href="Group.html#.set">set</a></li></ul></li><li><a href="Layer.html">Layer</a><ul class='methods'><li data-type='method'><a href="Layer.html#.activate">activate</a></li><li data-type='method'><a href="Layer.html#.clear">clear</a></li><li data-type='method'><a href="Layer.html#.connect">connect</a></li><li data-type='method'><a href="Layer.html#.Dense">Dense</a></li><li data-type='method'><a href="Layer.html#.disconnect">disconnect</a></li><li data-type='method'><a href="Layer.html#.gate">gate</a></li><li data-type='method'><a href="Layer.html#.GRU">GRU</a></li><li data-type='method'><a href="Layer.html#.LSTM">LSTM</a></li><li data-type='method'><a href="Layer.html#.Memory">Memory</a></li><li data-type='method'><a href="Layer.html#.propagate">propagate</a></li><li data-type='method'><a href="Layer.html#.set">set</a></li></ul></li><li><a href="Neat.html">Neat</a><ul class='methods'><li data-type='method'><a href="Neat.html">evolve</a></li><li data-type='method'><a href="Neat.html#.createPool">createPool</a></li><li data-type='method'><a href="Neat.html#.createPopulation">createPopulation</a></li><li data-type='method'><a href="Neat.html#.evalute">evalute</a></li><li data-type='method'><a href="Neat.html#.fromJSON">fromJSON</a></li><li data-type='method'><a href="Neat.html#.getAverage">getAverage</a></li><li data-type='method'><a href="Neat.html#.getFittest">getFittest</a></li><li data-type='method'><a href="Neat.html#.getOffspring">getOffspring</a></li><li data-type='method'><a href="Neat.html#.getParent">getParent</a></li><li data-type='method'><a href="Neat.html#.mutate">mutate</a></li><li data-type='method'><a href="Neat.html#.mutateRandom">mutateRandom</a></li><li data-type='method'><a href="Neat.html#.replace">replace</a></li><li data-type='method'><a href="Neat.html#.toJSON">toJSON</a></li></ul></li><li><a href="Network.html">Network</a><ul class='methods'><li data-type='method'><a href="Network.html#.activate">activate</a></li><li data-type='method'><a href="Network.html#.clear">clear</a></li><li data-type='method'><a href="Network.html#.clone">clone</a></li><li data-type='method'><a href="Network.html#.connect">connect</a></li><li data-type='method'><a href="Network.html#.crossOver">crossOver</a></li><li data-type='method'><a href="Network.html#.disconnect">disconnect</a></li><li data-type='method'><a href="Network.html#.evolve">evolve</a></li><li data-type='method'><a href="Network.html#.fromJSON">fromJSON</a></li><li data-type='method'><a href="Network.html#.gate">gate</a></li><li data-type='method'><a href="Network.html#.graph">graph</a></li><li data-type='method'><a href="Network.html#.merge">merge</a></li><li data-type='method'><a href="Network.html#.mutate">mutate</a></li><li data-type='method'><a href="Network.html#.noTraceActivate">noTraceActivate</a></li><li data-type='method'><a href="Network.html#.possible">possible</a></li><li data-type='method'><a href="Network.html#.remove">remove</a></li><li data-type='method'><a href="Network.html#.set">set</a></li><li data-type='method'><a href="Network.html#.standalone">standalone</a></li><li data-type='method'><a href="Network.html#.test">test</a></li><li data-type='method'><a href="Network.html#.toJSON">toJSON</a></li><li data-type='method'><a href="Network.html#.train">train</a></li><li data-type='method'><a href="Network.html#.ungate">ungate</a></li></ul></li><li><a href="Node.html">Node</a><ul class='methods'><li data-type='method'><a href="Node.html#.activate">activate</a></li><li data-type='method'><a href="Node.html#.clear">clear</a></li><li data-type='method'><a href="Node.html#.connect">connect</a></li><li data-type='method'><a href="Node.html#.disconnect">disconnect</a></li><li data-type='method'><a href="Node.html#.fromJSON">fromJSON</a></li><li data-type='method'><a href="Node.html#.gate">gate</a></li><li data-type='method'><a href="Node.html#.isProjectedBy">isProjectedBy</a></li><li data-type='method'><a href="Node.html#.isProjectingTo">isProjectingTo</a></li><li data-type='method'><a href="Node.html#.mutate">mutate</a></li><li data-type='method'><a href="Node.html#.noTraceActivate">noTraceActivate</a></li><li data-type='method'><a href="Node.html#.propagate">propagate</a></li><li data-type='method'><a href="Node.html#.toJSON">toJSON</a></li><li data-type='method'><a href="Node.html#.ungate">ungate</a></li></ul></li></ul><h3>Namespaces</h3><ul><li><a href="activation.html">activation</a><ul class='methods'><li data-type='method'><a href="activation.html#.ABSOLUTE">ABSOLUTE</a></li><li data-type='method'><a href="activation.html#.BENT_IDENTITY">BENT_IDENTITY</a></li><li data-type='method'><a href="activation.html#.BIPOLAR">BIPOLAR</a></li><li data-type='method'><a href="activation.html#.BIPOLAR_SIGMOID">BIPOLAR_SIGMOID</a></li><li data-type='method'><a href="activation.html#.GAUSSIAN">GAUSSIAN</a></li><li data-type='method'><a href="activation.html#.HARD_TANH">HARD_TANH</a></li><li data-type='method'><a href="activation.html#.IDENTITY">IDENTITY</a></li><li data-type='method'><a href="activation.html#.INVERSE">INVERSE</a></li><li data-type='method'><a href="activation.html#.LOGISTIC">LOGISTIC</a></li><li data-type='method'><a href="activation.html#.RELU">RELU</a></li><li data-type='method'><a href="activation.html#.SELU">SELU</a></li><li data-type='method'><a href="activation.html#.SINUSOID">SINUSOID</a></li><li data-type='method'><a href="activation.html#.SOFTSIGN">SOFTSIGN</a></li><li data-type='method'><a href="activation.html#.STEP">STEP</a></li><li data-type='method'><a href="activation.html#.TANH">TANH</a></li></ul></li><li><a href="architect.html">architect</a><ul class='methods'><li data-type='method'><a href="architect.html#.Construct">Construct</a></li><li data-type='method'><a href="architect.html#.GRU">GRU</a></li><li data-type='method'><a href="architect.html#.Hopfield">Hopfield</a></li><li data-type='method'><a href="architect.html#.Liquid">Liquid</a></li><li data-type='method'><a href="architect.html#.LSTM">LSTM</a></li><li data-type='method'><a href="architect.html#.NARX">NARX</a></li><li data-type='method'><a href="architect.html#.Perceptron">Perceptron</a></li><li data-type='method'><a href="architect.html#.Random">Random</a></li></ul></li><li><a href="connection.html">connection</a><ul class='members'><li data-type='member'><a href="connection.html#.ALL_TO_ALL">ALL_TO_ALL</a></li><li data-type='member'><a href="connection.html#.ALL_TO_ELSE">ALL_TO_ELSE</a></li><li data-type='member'><a href="connection.html#.ONE_TO_ONE">ONE_TO_ONE</a></li></ul></li><li><a href="cost.html">cost</a><ul class='methods'><li data-type='method'><a href="cost.html#.BINARY">BINARY</a></li><li data-type='method'><a href="cost.html#.CROSS_ENTROPY">CROSS_ENTROPY</a></li><li data-type='method'><a href="cost.html#.HINGE">HINGE</a></li><li data-type='method'><a href="cost.html#.MAE">MAE</a></li><li data-type='method'><a href="cost.html#.MAPE">MAPE</a></li><li data-type='method'><a href="cost.html#.MSE">MSE</a></li><li data-type='method'><a href="cost.html#.MSLE">MSLE</a></li><li data-type='method'><a href="cost.html#.WAPE">WAPE</a></li></ul></li><li><a href="crossover.html">crossover</a><ul class='members'><li data-type='member'><a href="crossover.html#.AVERAGE">AVERAGE</a></li><li data-type='member'><a href="crossover.html#.SINGLE_POINT">SINGLE_POINT</a></li><li data-type='member'><a href="crossover.html#.TWO_POINT">TWO_POINT</a></li><li data-type='member'><a href="crossover.html#.UNIFORM">UNIFORM</a></li></ul></li><li><a href="gating.html">gating</a><ul class='members'><li data-type='member'><a href="gating.html#.INPUT">INPUT</a></li><li data-type='member'><a href="gating.html#.OUTPUT">OUTPUT</a></li><li data-type='member'><a href="gating.html#.SELF">SELF</a></li></ul></li><li><a href="mutation.html">mutation</a><ul class='members'><li data-type='member'><a href="mutation.html#.ADD_BACK_CONN">ADD_BACK_CONN</a></li><li data-type='member'><a href="mutation.html#.ADD_CONN">ADD_CONN</a></li><li data-type='member'><a href="mutation.html#.ADD_GATE">ADD_GATE</a></li><li data-type='member'><a href="mutation.html#.ADD_NODE">ADD_NODE</a></li><li data-type='member'><a href="mutation.html#.ADD_SELF_CONN">ADD_SELF_CONN</a></li><li data-type='member'><a href="mutation.html#.ALL">ALL</a></li><li data-type='member'><a href="mutation.html#.FFW">FFW</a></li><li data-type='member'><a href="mutation.html#.MOD_ACTIVATION">MOD_ACTIVATION</a></li><li data-type='member'><a href="mutation.html#.MOD_BIAS">MOD_BIAS</a></li><li data-type='member'><a href="mutation.html#.MOD_WEIGHT">MOD_WEIGHT</a></li><li data-type='member'><a href="mutation.html#.SUB_BACK_CONN">SUB_BACK_CONN</a></li><li data-type='member'><a href="mutation.html#.SUB_CONN">SUB_CONN</a></li><li data-type='member'><a href="mutation.html#.SUB_GATE">SUB_GATE</a></li><li data-type='member'><a href="mutation.html#.SUB_NODE">SUB_NODE</a></li><li data-type='member'><a href="mutation.html#.SUB_SELF_CONN">SUB_SELF_CONN</a></li><li data-type='member'><a href="mutation.html#.SWAP_NODES">SWAP_NODES</a></li></ul></li><li><a href="rate.html">rate</a><ul class='methods'><li data-type='method'><a href="rate.html#.EXP">EXP</a></li><li data-type='method'><a href="rate.html#.FIXED">FIXED</a></li><li data-type='method'><a href="rate.html#.INV">INV</a></li><li data-type='method'><a href="rate.html#.STEP">STEP</a></li></ul></li><li><a href="selection.html">selection</a><ul class='members'><li data-type='member'><a href="selection.html#.FITNESS_PROPORTIONATE">FITNESS_PROPORTIONATE</a></li><li data-type='member'><a href="selection.html#.POWER">POWER</a></li><li data-type='member'><a href="selection.html#.TOURNAMENT">TOURNAMENT</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#config">config</a></li><li><a href="global.html#GAN">GAN</a></li><li><a href="global.html#sort">sort</a></li></ul>
</nav>

<div id="main">
    <div class="columns">
        <div class="column is-hidden-touch"></div>
        <div class="column is-11-desktop is-10-widescreen">

            
                <h1 class="page-title">architecture/layer.js</h1>
            

            



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>const _ = require("lodash");
const methods = require("../methods/methods");
const Group = require("./group");
const Node = require("./node");


/**
* Layers are pre-built architectures that allow you to combine different network architectures into 贸ne network.
*
* Always start your network with a `Dense` layer and always end it with a `Dense` layer. You can connect layers with each other just like you can connect [Nodes](Node) and [Groups](Group) with each other.
*
* @constructs Layer
*
* @prop {Node[]} output Output nodes
* @prop {Node[]} nodes Nodes within the layer
* @prop {Group[]|Node[]} connections.in Income connections
* @prop {Group[]|Node[]} connections.out Outgoing connections
* @prop {Group[]|Node[]} connections.self Self connections
*
* @example &lt;caption>Custom architecture built with layers&lt;/caption>
* let { Layer } = require("@liquid-carrot/carrot");
*
* let input = new Layer.Dense(1);
* let hidden1 = new Layer.LSTM(5);
* let hidden2 = new Layer.GRU(1);
* let output = new Layer.Dense(1);
*
* // connect however you want
* input.connect(hidden1);
* hidden1.connect(hidden2);
* hidden2.connect(output);
*
* let network = architect.Construct([input, hidden1, hidden2, output]);
*/
function Layer() {
  const self = this
  
  self.output = null;

  self.nodes = [];
  self.connections = {
    in: [],
    out: [],
    self: [],
    
    // (BETA)
    incoming: [],
    outgoing: []
  };
  
  
  /**
  * Activates all the nodes in the group
  *
  * @function activate
  * @memberof Layer
  *
  * @param {object[]} value Array with length equal to amount of nodes
  * @returns {number[]} Layer output values
  */
  self.activate = function(inputs) {
    const values = [];

    if(inputs != undefined &amp;&amp; inputs.length !== self.nodes.length) throw new Error('Array with values should be same as the amount of nodes!');

    for(let index = 0; index &lt; self.nodes.length; index++) {
      const activation = (inputs == undefined) ? self.nodes[index].activate() : self.nodes[index].activate(inputs[index]);
      
      values.push(activation);
    }

    return values;
  },

  /**
  * Propagates all the node in the group
  *
  * @function propagate
  * @memberof Layer
  *
  * @param {number[]} [target] Ideal/target values - _required for output layers_
  * @param {Object} [options]
  * @param {number} [options.rate=0.3] Sets the [learning rate](https://towardsdatascience.com/understanding-learning-rates-and-how-it-improves-performance-in-deep-learning-d0d4059c1c10) of the backpropagation process
  * @param {number} [options.momentum=0] [Momentum](https://www.willamette.edu/~gorr/classes/cs449/momrate.html). Adds a fraction of the previous weight update to the current one.
  * @param {boolean} [options.update=true]
  */
  self.propagate = function(targets, options) {
    if(targets != undefined &amp;&amp; targets.length !== self.nodes.length) throw new Error('Array with values should be same as the amount of nodes!');

    for(let index = self.nodes.length - 1; index >= 0; index--) {
      if(targets == undefined) self.nodes[index].propagate(options);
      else self.nodes[index].propagate(targets[index], options);
    }
  },

  /**
  * Connects the nodes in this group to nodes in another group or just a node
  *
  * @function connect
  * @memberof Layer
  *
  * @param {Group|Node|Layer} target Node(s) to form connections with
  * @param {connection} method [Connection Methods](connection)
  * @param {number} weight An initial weight to build the connections with
  *
  * @returns {Connection[]} An array of connections between the nodes in this layer and target
  */
  self.connect = function(target, method, weight) {
    if(target instanceof Group || target instanceof Node) return self.output.connect(target, method, weight);
    else if(target instanceof Layer) return target.input(self, method, weight);
  },

  /**
  * Make nodes from this group gate the given connection(s)
  *
  * @see [Synaptic Gating on Wikipedia](https://en.wikipedia.org/wiki/Synaptic_gating)
  *
  * @function gate
  * @memberof Layer
  *
  * @param {Connection[]} connections Connections to gate
  * @param {gating_method} method [Gating Method](gating)
  */
  self.gate = function(connections, method) {
    self.output.gate(connections, method);
  },

  /**
  * Sets the value of a property for every node
  *
  * @function set
  * @memberof Layer
  *
  * @param {object[]} values An object with (all optional) bias, squash, and type properties to overwrite in the node
  */
  self.set = function(values) {
    for(let i = 0; i &lt; self.nodes.length; i++) {
      const node = self.nodes[i];

      if(node instanceof Node) Object.assign(node, { ...values });
      else if(node instanceof Group) node.set(values);
    }
  },

  /**
  * Disconnects all nodes from this group from another given group/node
  *
  * @function disconnect
  * @memberof Layer
  *
  * @param {Group|Node|Layer} target A Group, Node, or Layer to disconnect from
  * @param {boolean} [twosided=false] Flag indicating incoming connections
  */
  self.disconnect = function(target, twosided) {
    twosided = twosided || false;

    if(target instanceof Group) {
      for(let i = 0; i &lt; self.nodes.length; i++) {
        for(let j = 0; j &lt; target.nodes.length; j++) {
          self.nodes[i].disconnect(target.nodes[j], twosided);

          if(twosided) self.connections.in = self.connections.in .filter(connection => !(connection.from === target.nodes[j] &amp;&amp; connection.to === self.nodes[i]))
          self.connections.out = self.connections.out.filter(connection => !(connection.from === self.nodes[i] &amp;&amp; connection.to === target.nodes[j]))
        }
      }
    } else if(target instanceof Node) {
      for(let i = 0; i &lt; self.nodes.length; i++) {
        self.nodes[i].disconnect(target, twosided);

        if(twosided) self.connections.in = self.connections.in .filter(connection => !(connection.from === target &amp;&amp; connection.to === self.nodes[i]))
        self.connections.out = self.connections.out.filter(connection => !(connection.from === self.nodes[i] &amp;&amp; connection.to === target))
      }
    }
  },

  /**
  * Clear the context of this group
  *
  * @function clear
  * @memberof Layer
  */
  self.clear = function() {
    for(let index = 0; index &lt; self.nodes.length; index++) {
      self.nodes[index].clear();
    }
  }
}

/**
* Creates a regular (dense) layer.
*
* @param {number} size Amount of nodes to build the layer with
*
* @returns {Layer} Plain layer
*
* @example
* let { Layer } = require("@liquid-carrot/carrot");
*
* let layer = new Layer.Dense(size);
*/
Layer.Dense = function(size) {
  // Create the layer
  const layer = new Layer();

  // Init required nodes (in activation order)
  const block = new Group(size);

  layer.nodes.push(block);
  layer.output = block;

  layer.input = function(from, method, weight) {
    if(from instanceof Layer) from = from.output;
    
    method = method || methods.connection.ALL_TO_ALL;
    
    return from.connect(block, method, weight);
  };

  return layer;
};

/**
* Creates an LSTM layer.
*
* LSTM layers are useful for detecting and predicting patterns over long time lags. This is a recurrent layer.
*
* Note: architect.LSTM currently performs better than an equivalent network built with LSTM Layers.
*
* @param {number} size Amount of nodes to build the layer with
*
* @returns {Layer} LSTM layer
*
* @example
* let { Layer } = require("@liquid-carrot/carrot");
*
* let layer = new Layer.LSTM(size);
*/
Layer.LSTM = function(size) {
  // Create the layer
  const layer = new Layer();

  // Init required nodes (in activation order)
  const input_gate = new Group(size);
  const forget_gate = new Group(size);
  const memory_cell = new Group(size);
  const output_gate = new Group(size);
  const output_block = new Group(size);

  input_gate.set({
    bias: 1
  });
  forget_gate.set({
    bias: 1
  });
  output_gate.set({
    bias: 1
  });

  // Set up internal connections
  memory_cell.connect(input_gate, methods.connection.ALL_TO_ALL);
  memory_cell.connect(forget_gate, methods.connection.ALL_TO_ALL);
  memory_cell.connect(output_gate, methods.connection.ALL_TO_ALL);
  const forget = memory_cell.connect(memory_cell, methods.connection.ONE_TO_ONE);
  const output = memory_cell.connect(output_block, methods.connection.ALL_TO_ALL);

  // Set up gates
  forget_gate.gate(forget, methods.gating.SELF);
  output_gate.gate(output, methods.gating.OUTPUT);

  // Add to nodes array
  layer.nodes = [input_gate, forget_gate, memory_cell, output_gate, output_block];

  // Define output
  layer.output = output_block;

  layer.input = function(from, method, weight) {
    if(from instanceof Layer) from = from.output;
    method = method || methods.connection.ALL_TO_ALL;

    const input = from.connect(memory_cell, method, weight);
    
    const connections = [
      input,
      from.connect(input_gate, method, weight),
      from.connect(output_gate, method, weight),
      from.connect(forget_gate, method, weight)
    ];

    input_gate.gate(input, methods.gating.INPUT);

    return connections;
  };

  return layer;
};

/**
* Creates a GRU layer.
*
* The GRU layer is similar to the LSTM layer, however it has no memory cell and only two gates. It is also a recurrent layer that is excellent for timeseries prediction.
*
* @param {number} size Amount of nodes to build the layer with
*
* @returns {Layer} GRU layer
*
* @example
* let { Layer } = require("@liquid-carrot/carrot");
*
* let layer = new Layer.GRU(size);
*/
Layer.GRU = function(size) {
  // Create the layer
  const layer = new Layer();

  const update_gate = new Group(size);
  const inverse_update_gate = new Group(size);
  const reset_gate = new Group(size);
  const memory_cell = new Group(size);
  const output = new Group(size);
  const previous_output = new Group(size);

  previous_output.set({
    bias: 0,
    squash: methods.activation.IDENTITY,
    type: 'constant'
  });
  memory_cell.set({
    squash: methods.activation.TANH
  });
  inverse_update_gate.set({
    bias: 0,
    squash: methods.activation.INVERSE,
    type: 'constant'
  });
  update_gate.set({
    bias: 1
  });
  reset_gate.set({
    bias: 0
  });

  // Update gate calculation
  previous_output.connect(update_gate, methods.connection.ALL_TO_ALL);

  // Inverse update gate calculation
  update_gate.connect(inverse_update_gate, methods.connection.ONE_TO_ONE, 1);

  // Reset gate calculation
  previous_output.connect(reset_gate, methods.connection.ALL_TO_ALL);

  // Memory calculation
  const reset = previous_output.connect(memory_cell, methods.connection.ALL_TO_ALL);

  reset_gate.gate(reset, methods.gating.OUTPUT); // gate

  // Output calculation
  const update1 = previous_output.connect(output, methods.connection.ALL_TO_ALL);
  const update2 = memory_cell.connect(output, methods.connection.ALL_TO_ALL);

  update_gate.gate(update1, methods.gating.OUTPUT);
  inverse_update_gate.gate(update2, methods.gating.OUTPUT);

  // Previous output calculation
  output.connect(previous_output, methods.connection.ONE_TO_ONE, 1);

  // Add to nodes array
  layer.nodes = [update_gate, inverse_update_gate, reset_gate, memory_cell, output, previous_output];

  layer.output = output;

  layer.input = function(from, method, weight) {
    if(from instanceof Layer) from = from.output;
    
    method = method || methods.connection.ALL_TO_ALL;
    
    const connections = [
      from.connect(updateGate, method, weight),
      from.connect(resetGate, method, weight),
      from.connect(memoryCell, method, weight)
    ];

    return connections;
  };

  return layer;
};

/**
* Creates a Memory layer.
*
* The Memory layer makes networks remember a number of previous inputs in an absolute way. For example, if you set the memory option to 3, it will remember the last 3 inputs in the same state as they were inputted.
*
* @param {number} size Amount of nodes to build the layer with
* @param {number} memory Number of previous inputs to remember
*
* @returns {Layer} Layer with nodes that store previous inputs
*
* @example
* let { Layer } = require("@liquid-carrot/carrot");
*
* let layer = new Layer.Memory(size, memory);
*/
Layer.Memory = function(size, memory) {
  // Create the layer
  const layer = new Layer();
  // Because the output can only be one group, we have to put the nodes all in 贸ne group

  let previous;
  for (let index = 0; index &lt; memory; index++) {
    const block = new Group(size);

    block.set({
      squash: methods.activation.IDENTITY,
      bias: 0,
      type: 'constant'
    });

    if (previous != undefined) previous.connect(block, methods.connection.ONE_TO_ONE, 1);

    layer.nodes.push(block);
    previous = block;
  }

  layer.nodes.reverse();

  // Because output can only be 贸ne group, fit all memory nodes in 贸ne group
  const output_group = new Group(0);
  for (let index = 0; index &lt; layer.nodes.length; index++) {
    layer.nodes[index].nodes.reverse();
    output_group.nodes = output_group.nodes.concat(layer.nodes[index].nodes);
  }
  
  layer.output = output_group;

  layer.input = function(from, method, weight) {
    if (from instanceof Layer) from = from.output;
    method = method || methods.connection.ALL_TO_ALL;

    if (from.nodes.length !== layer.nodes[layer.nodes.length - 1].nodes.length) throw new Error('Previous layer size must be same as memory size');

    return from.connect(layer.nodes[layer.nodes.length - 1], methods.connection.ONE_TO_ONE, 1);
  };

  return layer;
};

module.exports = Layer;
</code></pre>
        </article>
    </section>





            

        </div>
        <div class="column is-hidden-touch"></div>
    </div>
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.1</a> on Tue Jun 25 2019 19:16:26 GMT-0400 (Eastern Daylight Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>
<script src="scripts/linenumber.js"></script>

<script src="scripts/jquery-3.1.1.min.js"></script>

<script src="scripts/search.js"></script>




<script type="text/javascript">
  window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var r=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(r?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["addEventProperties","addUserProperties","clearEventProperties","identify","resetIdentity","removeEventProperty","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])};
  heap.load("1195922815");
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {

  // Get all "navbar-burger" elements
  const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);

  // Check if there are any navbar burgers
  if ($navbarBurgers.length > 0) {

    // Add a click event on each of them
    $navbarBurgers.forEach( el => {
      el.addEventListener('click', () => {

        // Get the target from the "data-target" attribute
        const target = el.dataset.target;
        const $target = document.getElementById(target);

        // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
        el.classList.toggle('is-active');
        $target.classList.toggle('is-active');

      });
    });
  }

});
</script>
<script>prettyPrint();</script>
</body>
</html>
