<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>Liquid Carrot - architecture/Node.js - Documentation</title>
    <link rel="shortcut icon" href="/liquid-carrot-favicon.png" />
    
    
    
    
    
    <meta property="og:title" content=""/>
    <meta property="og:type" content="website"/>
    <meta property="og:image" content=""/>
    
    <meta property="og:url" content=""/>
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link rel="stylesheet" href="styles/bulma.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <link href="https://fonts.googleapis.com/css?family=Montserrat:400,700" rel="stylesheet">
    <link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/ionicons/2.0.1/css/ionicons.min.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger">
  <div class="fixed-action-btn">
    <div class="button-floating">
      <!--
      <label for="nav-trigger" class="navicon-button x">
        <div class="navicon"></div>
      </label>
      -->
        <i class="ion-ios-book" aria-hidden="true"></i>
    </div>
  </div>
</label>
<label for="nav-trigger" class="overlay"></label>

<div class="navbar is-fixed-top" role="navigation" aria-label="main navigation">
  <div class="navbar-brand">
    <a class="navbar-item" href="#" style="padding:0">
      <img src="img/carrot-logo.png" height="28">
    </a>

    <a role="button" class="navbar-burger burger" aria-label="menu" aria-expanded="false" data-target="navbarBasicExample">
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
      <span aria-hidden="true"></span>
    </a>
  </div>

  <div id="navbarBasicExample" class="navbar-menu">
    <div class="navbar-start">
      <a class="navbar-item" href="/">Home</a>
      <a class="navbar-item" href="/carrot">Docs</a>
      <a class="navbar-item" href="https://github.com/liquidcarrot/carrot" target="_blank"><i class="ion-social-github" aria-hidden="true"></i></a>
      <div class="navbar-item has-dropdown is-hoverable">
        <a class="navbar-link">
          Versions
        </a>
        
        <div class="navbar-dropdown">
          <a href='https://liquidcarrot.io/carrot/versions/0.2.27/' class="navbar-item">v0.2.27</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.2.28/' class="navbar-item">v0.2.28</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.0/' class="navbar-item">v0.3.0</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.1/' class="navbar-item">v0.3.1</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.10/' class="navbar-item">v0.3.10</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.11/' class="navbar-item">v0.3.11</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.12/' class="navbar-item">v0.3.12</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.16/' class="navbar-item">v0.3.16</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.18/' class="navbar-item">v0.3.18</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.3/' class="navbar-item">v0.3.3</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.4/' class="navbar-item">v0.3.4</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.7/' class="navbar-item">v0.3.7</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.8/' class="navbar-item">v0.3.8</a>
      <a href='https://liquidcarrot.io/carrot/versions/0.3.9/' class="navbar-item">v0.3.9</a>
      <a href='https://liquidcarrot.io/carrot/' class="navbar-item">latest</a>
        </div>
      </div>
      <div class="navbar-item has-dropdown is-hoverable">
        <a class="navbar-link">
          More
        </a>

        <div class="navbar-dropdown">
          <a class="navbar-item" href="mailto:people@liquidcarrot.io?subject=Contact%20From%20Docs">
            Contact
          </a>
          <hr class="navbar-divider">
          <a class="navbar-item" href="https://github.com/liquidcarrot/carrot/issues/new">
            Report an issue
          </a>
        </div>
      </div>
    </div>

    <div class="navbar-end">
      <div class="navbar-item">
        <input type="text" id="nav-search" placeholder="Search" autofocus>
      </div>
    </div>
  </div>
</div>

<nav >
    <h3>Classes</h3><ul><li><a href="Neat.html">Neat</a><ul class='methods'><li data-type='method'><a href="Neat.html#evaluate">evaluate</a></li><li data-type='method'><a href="Neat.html#evolve">evolve</a></li><li data-type='method'><a href="Neat.html#filterGenome">filterGenome</a></li><li data-type='method'><a href="Neat.html#getAverage">getAverage</a></li><li data-type='method'><a href="Neat.html#getFittest">getFittest</a></li><li data-type='method'><a href="Neat.html#getOffspring">getOffspring</a></li><li data-type='method'><a href="Neat.html#mutate">mutate</a></li><li data-type='method'><a href="Neat.html#mutateRandom">mutateRandom</a></li><li data-type='method'><a href="Neat.html#sort">sort</a></li></ul></li><li><a href="Network.html">Network</a><ul class='methods'><li data-type='method'><a href="Network.html#.crossOver">crossOver</a></li><li data-type='method'><a href="Network.html#.fromJSON">fromJSON</a></li><li data-type='method'><a href="Network.html#activate">activate</a></li><li data-type='method'><a href="Network.html#addGate">addGate</a></li><li data-type='method'><a href="Network.html#clear">clear</a></li><li data-type='method'><a href="Network.html#connect">connect</a></li><li data-type='method'><a href="Network.html#copy">copy</a></li><li data-type='method'><a href="Network.html#disconnect">disconnect</a></li><li data-type='method'><a href="Network.html#evolve">evolve</a></li><li data-type='method'><a href="Network.html#mutate">mutate</a></li><li data-type='method'><a href="Network.html#mutateRandom">mutateRandom</a></li><li data-type='method'><a href="Network.html#propagate">propagate</a></li><li data-type='method'><a href="Network.html#removeGate">removeGate</a></li><li data-type='method'><a href="Network.html#removeNode">removeNode</a></li><li data-type='method'><a href="Network.html#test">test</a></li><li data-type='method'><a href="Network.html#toJSON">toJSON</a></li><li data-type='method'><a href="Network.html#train">train</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#AbsoluteActivation">AbsoluteActivation</a></li><li><a href="global.html#Activation">Activation</a></li><li><a href="global.html#ActivationType">ActivationType</a></li><li><a href="global.html#ActivationType%255Bundefined%255D">ActivationType[undefined]</a></li><li><a href="global.html#AddBackConnectionMutation">AddBackConnectionMutation</a></li><li><a href="global.html#AddConnectionMutation">AddConnectionMutation</a></li><li><a href="global.html#AddGateMutation">AddGateMutation</a></li><li><a href="global.html#AddNodeMutation">AddNodeMutation</a></li><li><a href="global.html#AddSelfConnectionMutation">AddSelfConnectionMutation</a></li><li><a href="global.html#ALL_MUTATIONS">ALL_MUTATIONS</a></li><li><a href="global.html#Architect">Architect</a></li><li><a href="global.html#avg">avg</a></li><li><a href="global.html#AvgPooling1DLayer">AvgPooling1DLayer</a></li><li><a href="global.html#BentIdentityActivation">BentIdentityActivation</a></li><li><a href="global.html#BinaryLoss">BinaryLoss</a></li><li><a href="global.html#BipolarActivation">BipolarActivation</a></li><li><a href="global.html#BipolarSigmoidActivation">BipolarSigmoidActivation</a></li><li><a href="global.html#Connection">Connection</a></li><li><a href="global.html#ConnectionType">ConnectionType</a></li><li><a href="global.html#ConnectionType%255Bundefined%255D">ConnectionType[undefined]</a></li><li><a href="global.html#ConstantNode">ConstantNode</a></li><li><a href="global.html#CrossEntropyLoss">CrossEntropyLoss</a></li><li><a href="global.html#DenseLayer">DenseLayer</a></li><li><a href="global.html#DropoutLayer">DropoutLayer</a></li><li><a href="global.html#DropoutNode">DropoutNode</a></li><li><a href="global.html#ExponentialRate">ExponentialRate</a></li><li><a href="global.html#FEEDFORWARD_MUTATIONS">FEEDFORWARD_MUTATIONS</a></li><li><a href="global.html#FitnessProportionateSelection">FitnessProportionateSelection</a></li><li><a href="global.html#FixedRate">FixedRate</a></li><li><a href="global.html#GatingType">GatingType</a></li><li><a href="global.html#GatingType%255Bundefined%255D">GatingType[undefined]</a></li><li><a href="global.html#GaussianActivation">GaussianActivation</a></li><li><a href="global.html#generateGaussian">generateGaussian</a></li><li><a href="global.html#getOrDefault">getOrDefault</a></li><li><a href="global.html#GlobalAvgPooling1DLayer">GlobalAvgPooling1DLayer</a></li><li><a href="global.html#GlobalMaxPooling1DLayer">GlobalMaxPooling1DLayer</a></li><li><a href="global.html#GlobalMinPooling1DLayer">GlobalMinPooling1DLayer</a></li><li><a href="global.html#GRULayer">GRULayer</a></li><li><a href="global.html#HardTanhActivation">HardTanhActivation</a></li><li><a href="global.html#HINGELoss">HINGELoss</a></li><li><a href="global.html#HopfieldLayer">HopfieldLayer</a></li><li><a href="global.html#IdentityActivation">IdentityActivation</a></li><li><a href="global.html#InputLayer">InputLayer</a></li><li><a href="global.html#InverseActivation">InverseActivation</a></li><li><a href="global.html#InverseRate">InverseRate</a></li><li><a href="global.html#Layer">Layer</a></li><li><a href="global.html#LogisticActivation">LogisticActivation</a></li><li><a href="global.html#Loss">Loss</a></li><li><a href="global.html#LSTMLayer">LSTMLayer</a></li><li><a href="global.html#MAELoss">MAELoss</a></li><li><a href="global.html#MAPELoss">MAPELoss</a></li><li><a href="global.html#max">max</a></li><li><a href="global.html#MaxPooling1DLayer">MaxPooling1DLayer</a></li><li><a href="global.html#maxValueIndex">maxValueIndex</a></li><li><a href="global.html#MemoryLayer">MemoryLayer</a></li><li><a href="global.html#min">min</a></li><li><a href="global.html#MinPooling1DLayer">MinPooling1DLayer</a></li><li><a href="global.html#minValueIndex">minValueIndex</a></li><li><a href="global.html#MISHActivation">MISHActivation</a></li><li><a href="global.html#ModActivationMutation">ModActivationMutation</a></li><li><a href="global.html#ModBiasMutation">ModBiasMutation</a></li><li><a href="global.html#ModWeightMutation">ModWeightMutation</a></li><li><a href="global.html#MSELoss">MSELoss</a></li><li><a href="global.html#MSLELoss">MSLELoss</a></li><li><a href="global.html#Mutation">Mutation</a></li><li><a href="global.html#Node">Node</a></li><li><a href="global.html#NodeType">NodeType</a></li><li><a href="global.html#NodeType%255Bundefined%255D">NodeType[undefined]</a></li><li><a href="global.html#NoiseLayer">NoiseLayer</a></li><li><a href="global.html#NoiseNode">NoiseNode</a></li><li><a href="global.html#NoiseNodeType">NoiseNodeType</a></li><li><a href="global.html#NoiseNodeType%255Bundefined%255D">NoiseNodeType[undefined]</a></li><li><a href="global.html#OutputLayer">OutputLayer</a></li><li><a href="global.html#pickRandom">pickRandom</a></li><li><a href="global.html#PoolingLayer">PoolingLayer</a></li><li><a href="global.html#PoolNode">PoolNode</a></li><li><a href="global.html#PoolNodeType">PoolNodeType</a></li><li><a href="global.html#PoolNodeType%255Bundefined%255D">PoolNodeType[undefined]</a></li><li><a href="global.html#PowerSelection">PowerSelection</a></li><li><a href="global.html#randBoolean">randBoolean</a></li><li><a href="global.html#randDouble">randDouble</a></li><li><a href="global.html#randInt">randInt</a></li><li><a href="global.html#Rate">Rate</a></li><li><a href="global.html#RELUActivation">RELUActivation</a></li><li><a href="global.html#removeFromArray">removeFromArray</a></li><li><a href="global.html#RNNLayer">RNNLayer</a></li><li><a href="global.html#Selection">Selection</a></li><li><a href="global.html#SELUActivation">SELUActivation</a></li><li><a href="global.html#shuffle">shuffle</a></li><li><a href="global.html#SinusoidActivation">SinusoidActivation</a></li><li><a href="global.html#SoftSignActivation">SoftSignActivation</a></li><li><a href="global.html#StepActivation">StepActivation</a></li><li><a href="global.html#StepRate">StepRate</a></li><li><a href="global.html#SubBackConnectionMutation">SubBackConnectionMutation</a></li><li><a href="global.html#SubConnectionMutation">SubConnectionMutation</a></li><li><a href="global.html#SubGateMutation">SubGateMutation</a></li><li><a href="global.html#SubNodeMutation">SubNodeMutation</a></li><li><a href="global.html#SubSelfConnectionMutation">SubSelfConnectionMutation</a></li><li><a href="global.html#sum">sum</a></li><li><a href="global.html#SwapNodesMutation">SwapNodesMutation</a></li><li><a href="global.html#TanhActivation">TanhActivation</a></li><li><a href="global.html#TournamentSelection">TournamentSelection</a></li><li><a href="global.html#WAPELoss">WAPELoss</a></li></ul>
</nav>

<div id="main">
    <div class="columns">
        <div class="column is-hidden-touch"></div>
        <div class="column is-11-desktop is-10-widescreen">

            
                <h1 class="page-title">architecture/Node.js</h1>
            

            



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ActivationType_1 = require("../enums/ActivationType");
var NodeType_1 = require("../enums/NodeType");
var Activation_1 = require("../methods/Activation");
var Mutation_1 = require("../methods/Mutation");
var Utils_1 = require("../methods/Utils");
var Connection_1 = require("./Connection");
/**
 * Creates a new neuron/node
 *
 * Neurons are the basic unit of the neural network. They can be connected together, or used to gate connections between other neurons. A Neuron can perform basically 4 operations: form connections, gate connections, activate and [propagate](https://www.youtube.com/watch?v=Ilg3gGewQ5U).
 *
 * For more information check:
 * - [here](https://becominghuman.ai/what-is-an-artificial-neuron-8b2e421ce42e)
 * - [here](https://en.wikipedia.org/wiki/Artificial_neuron)
 * - [here](https://wagenaartje.github.io/neataptic/docs/architecture/node/)
 * - [here](https://github.com/cazala/synaptic/wiki/Neural-Networks-101)
 * - [here](https://keras.io/backend/#bias_add)
 *
 * @prop {number} previousDeltaBias
 * @prop {number} totalDeltaBias
 * @prop {number} error.responsibility
 * @prop {number} error.projected
 * @prop {number} error.gated
 *
 * @example
 * let { Node } = require("@liquid-carrot/carrot");
 *
 * let node = new Node();
 */
var Node = /** @class */ (function () {
    function Node(type) {
        if (type === void 0) { type = NodeType_1.NodeType.HIDDEN; }
        this.type = type;
        this.bias = Utils_1.randDouble(-1, 1);
        this.squash = new Activation_1.LogisticActivation();
        this.activation = 0;
        this.derivativeState = 1;
        this.state = 0;
        this.old = 0;
        this.mask = 1;
        this.deltaBiasPrevious = 0;
        this.deltaBiasTotal = 0;
        this.incoming = [];
        this.outgoing = [];
        this.gated = [];
        this.selfConnection = new Connection_1.Connection(this, this, 0);
        this.errorResponsibility = 0;
        this.errorProjected = 0;
        this.errorGated = 0;
        this.index = NaN;
    }
    /**
     * Convert a json object to a node
     *
     * @param json A node represented as a JSON object
     *
     * @returns itself
     *
     * @example &lt;caption>From Node.toJSON()&lt;/caption>
     * const { Node } = require("@liquid-carrot/carrot");
     *
     * let otherNode = new Node();
     * let json = otherNode.toJSON();
     * let node = Node.fromJSON(json);
     *
     * console.log(node);
     */
    Node.prototype.fromJSON = function (json) {
        var _a, _b, _c, _d;
        this.bias = (_a = json.bias) !== null &amp;&amp; _a !== void 0 ? _a : Utils_1.randDouble(-1, 1);
        this.type = json.type;
        this.squash = Activation_1.Activation.getActivation((_b = json.squash) !== null &amp;&amp; _b !== void 0 ? _b : ActivationType_1.ActivationType.LogisticActivation);
        this.mask = (_c = json.mask) !== null &amp;&amp; _c !== void 0 ? _c : 1;
        this.index = (_d = json.index) !== null &amp;&amp; _d !== void 0 ? _d : NaN;
        return this;
    };
    /**
     * Clears this node's state information - _i.e. resets node and its connections to "factory settings"_
     *
     * `node.clear()` is useful for predicting time series.
     *
     * @example
     * const { Node } = require("@liquid-carrot/carrot");
     *
     * let node = new Node();
     *
     * node.activate([1, 0]);
     * node.propagate([1]);
     *
     * console.log(node); // Node has state information (e.g. `node.derivative`)
     *
     * node.clear(); // Factory resets node
     *
     * console.log(node); // Node has no state information
     */
    Node.prototype.clear = function () {
        for (var _i = 0, _a = this.incoming; _i &lt; _a.length; _i++) {
            var connection = _a[_i];
            connection.eligibility = 0;
            connection.xTraceNodes = [];
            connection.xTraceValues = [];
        }
        for (var _b = 0, _c = this.gated; _b &lt; _c.length; _b++) {
            var connection = _c[_b];
            connection.gain = 0;
        }
        this.errorResponsibility = this.errorProjected = this.errorGated = 0;
        this.old = this.state = this.activation = 0;
    };
    /**
     * Mutates the node's bias
     *
     * @param method The method is needed for the min and max value of the node's bias otherwise a range of [-1,1] is chosen
     *
     * @example
     * const { Node } = require("@liquid-carrot/carrot");
     *
     * let node = new Node();
     *
     * console.log(node);
     *
     * node.mutateBias(); // Changes node's bias
     */
    Node.prototype.mutateBias = function (method) {
        if (method === void 0) { method = new Mutation_1.ModBiasMutation(); }
        this.bias += Utils_1.randDouble(method.min, method.max); // add a random value in range [min,max)
    };
    /**
     * Mutates the node's activation function
     *
     * @example
     * const { Node } = require("@liquid-carrot/carrot");
     *
     * let node = new Node();
     *
     * console.log(node);
     *
     * node.mutateBias(); // Changes node's activation function
     */
    Node.prototype.mutateActivation = function (allowedActivations) {
        var _this = this;
        if (allowedActivations === void 0) { allowedActivations = Activation_1.ALL_ACTIVATIONS; }
        // pick a random activation from allowed activations except the current activation
        var possible = allowedActivations.filter(function (activation) { return activation !== _this.squash.type; });
        if (possible.length > 0) {
            var newActivationType = Utils_1.pickRandom(possible);
            this.squash = Activation_1.Activation.getActivation(newActivationType);
        }
    };
    /**
     * Checks if the given node(s) are have outgoing connections to this node
     *
     * @param node Checks if `node(s)` have outgoing connections into this node
     *
     * @return Returns true, if every node(s) has an outgoing connection into this node
     *
     * @example &lt;caption>Check one &lt;code>node&lt;/code>&lt;/caption>
     * const { Node } = require("@liquid-carrot/carrot");
     *
     * let otherNode = new Node();
     * let node = new Node();
     * otherNode.connect(node);
     *
     * console.log(node.isProjectedBy(otherNode)); // true
     *
     * @example &lt;caption>Check many &lt;code>nodes&lt;/code>&lt;/caption>
     * const { Node } = require("@liquid-carrot/carrot");
     *
     * let otherNodes = Array.from({ length: 5 }, () => new Node());
     * let node = new Node();
     *
     * otherNodes.forEach(otherNode => otherNode.connect(node));
     *
     * console.log(node.isProjectedBy(otherNodes)); // true
     */
    Node.prototype.isProjectedBy = function (node) {
        if (node === this) { // self connection
            return this.selfConnection.weight !== 0; // is projected, if weight of self connection is unequal 0
        }
        else {
            return this.incoming.map(function (conn) { return conn.from; }).includes(node); // check every incoming connection for node
        }
    };
    /**
     * Checks if this node has an outgoing connection(s) into the given node(s)
     *
     * @param node Checks if this node has outgoing connection(s) into `node(s)`
     *
     * @returns Returns true, if this node has an outgoing connection into every node(s)
     *
     * @example &lt;caption>Check one &lt;code>node&lt;/code>&lt;/caption>
     * const { Node } = require("@liquid-carrot/carrot");
     *
     * let otherNode = new Node();
     * let node = new Node();
     * node.connect(otherNode);
     *
     * console.log(node.isProjectingTo(otherNode)); // true
     *
     * @example &lt;caption>Check many &lt;code>nodes&lt;/code>&lt;/caption>
     * const { Node } = require("@liquid-carrot/carrot");
     *
     * let otherNodes = Array.from({ length: 5 }, () => new Node());
     * let node = new Node();
     *
     * otherNodes.forEach(otherNode => node.connect(otherNode));
     *
     * console.log(node.isProjectingTo(otherNodes)); // true
     */
    Node.prototype.isProjectingTo = function (node) {
        if (node === this) { // self connection
            return this.selfConnection.weight !== 0; // is projected, if weight of self connection is unequal 0
        }
        else {
            return this.outgoing.map(function (conn) { return conn.to; }).includes(node); // check every outgoing connection for node
        }
    };
    /**
     * This node gates (influences) the given connection
     *
     * @param connection Connection to be gated (influenced) by a neuron
     *
     * @example &lt;caption>Gate one &lt;code>connection&lt;/code>&lt;/caption>
     * const { Node } = require("@liquid-carrot/carrot");
     *
     * let input = new Node();
     * let output = new Node();
     * let connection = input.connect(output);
     *
     * let node = new Node();
     *
     * console.log(connection.gateNode === node); // false
     *
     * node.gate(connection); // Node now gates (manipulates) `connection`
     *
     * console.log(connection.gateNode === node); // true
     */
    Node.prototype.addGate = function (connection) {
        this.gated.push(connection);
        connection.gateNode = this;
    };
    /**
     * Stops this node from gating (manipulating) the given connection(s)
     *
     * @param connection Connections to remove gate - _i.e. remove this node from_
     *
     * @example &lt;caption>Remove gate one &lt;code>connection&lt;/code>&lt;/caption>
     * const { Node } = require("@liquid-carrot/carrot");
     *
     * let input = new Node();
     * let output = new Node();
     * let connection = input.connect(output);
     *
     * let node = new Node();
     *
     * console.log(connection.gateNode === node); // false
     *
     * node.addGate(connection); // Node now gates (manipulates) `connection`
     *
     * console.log(connection.gateNode === node); // true
     *
     * node.removeGate(connection); // Node is removed from `connection`
     *
     * console.log(connection.gateNode === node); // false
     */
    Node.prototype.removeGate = function (connection) {
        Utils_1.removeFromArray(this.gated, connection);
        connection.gateNode = null;
        connection.gain = 1;
    };
    /**
     * Connects this node to the given node(s)
     *
     * @param target Node(s) to project connection(s) to
     * @param weight Initial connection(s) [weight](https://en.wikipedia.org/wiki/Synaptic_weight)
     * @param twoSided If `true` connect nodes to each other
     *
     * @example &lt;caption>Connecting node (neuron) to another node (neuron)&lt;/caption>
     * const { Node } = require("@liquid-carrot/carrot");
     *
     * let node = new Node();
     * let otherNode = new Node();
     *
     * let connection = node.connect(otherNode); // Both nodes now share a connection
     *
     * console.log(connection); // Connection { from: [Object object], to: [Object object], ...}
     *
     *
     * @example &lt;caption>Connecting a node (neuron) to itself&lt;/caption>
     * const { Node } = require("@liquid-carrot/carrot");
     *
     * let node = new Node();
     *
     * let connection = node.connect(node); // Node is connected to itself.
     *
     * console.log(connection); // Connection { from: [Object object], to: [Object object], ...}
     */
    Node.prototype.connect = function (target, weight, twoSided) {
        if (weight === void 0) { weight = 1; }
        if (twoSided === void 0) { twoSided = false; }
        if (target === this) { // self connection
            this.selfConnection.weight = weight;
            return this.selfConnection;
        }
        else if (this.isProjectingTo(target)) {
            throw new ReferenceError(); // already connected
        }
        else {
            var connection = new Connection_1.Connection(this, target, weight); // create new connection
            // add it to the arrays
            this.outgoing.push(connection);
            target.incoming.push(connection);
            if (twoSided) {
                target.connect(this); // connect in the other direction
            }
            return connection;
        }
    };
    /**
     * Disconnects this node from the given node(s)
     *
     * @param node Node(s) to remove connection(s) to
     * @param twoSided=false If `true` disconnects nodes from each other (i.e. both sides)
     *
     * @example &lt;caption>Disconnect from one &lt;code>node&lt;/code>&lt;/caption>
     * const { Node } = require("@liquid-carrot/carrot");
     *
     * let node = new Node();
     * let other = new Node();
     *
     * node.connect(other); // `node` now connected to `other`
     *
     * console.log(node.incoming.length); // 0
     * console.log(node.outgoing.length); // 1
     *
     * node.disconnect(other); // `node` is now disconnected from `other`
     *
     * console.log(node.incoming.length); // 0
     * console.log(node.outgoing.length); // 0
     *
     * @example &lt;caption>Connect to one &lt;code>node&lt;/code> - &lt;em>two-sided&lt;/em>&lt;/caption>
     * const { Node } = require("@liquid-carrot/carrot");
     *
     * let node = new Node();
     * let other = new Node();
     *
     * // `node` &amp; `other` are now connected to each other
     * node.connect(other, true);
     *
     * console.log(node.incoming.length); // 1
     * console.log(node.outgoing.length); // 1
     *
     * // `node` &amp; `other` are now disconnected from each other
     * node.disconnect(other, true);
     *
     * console.log(node.incoming.length); // 0
     * console.log(node.outgoing.length); // 0
     */
    Node.prototype.disconnect = function (node, twoSided) {
        if (twoSided === void 0) { twoSided = false; }
        if (node === this) { // self connection
            this.selfConnection.weight = 0; // set weight to 0
            return this.selfConnection;
        }
        var connections = this.outgoing.filter(function (conn) { return conn.to === node; });
        if (connections.length === 0) {
            throw new Error("No Connection found");
        }
        var connection = connections[0];
        // remove it from the arrays
        Utils_1.removeFromArray(this.outgoing, connection);
        Utils_1.removeFromArray(connection.to.incoming, connection);
        if (connection.gateNode !== undefined &amp;&amp; connection.gateNode != null) {
            connection.gateNode.removeGate(connection); // if connection is gated -> remove gate
        }
        if (twoSided) {
            node.disconnect(this); // disconnect the other direction
        }
        return connection;
    };
    /**
     * Backpropagate the error (a.k.a. learn).
     *
     * After an activation, you can teach the node what should have been the correct output (a.k.a. train). This is done by backpropagating. [Momentum](https://www.willamette.edu/~gorr/classes/cs449/momrate.html) adds a fraction of the previous weight update to the current one. When the gradient keeps pointing in the same direction, this will increase the size of the steps taken towards the minimum.
     *
     * If you combine a high learning rate with a lot of momentum, you will rush past the minimum (of the error function) with huge steps. It is therefore often necessary to reduce the global learning rate Âµ when using a lot of momentum (m close to 1).
     *
     * @param target The target value (i.e. "the value the network SHOULD have given")
     * @param options More options for propagation
     *
     * @example
     * let { Node } = require("@liquid-carrot/carrot");
     *
     * let A = new Node();
     * let B = new Node('output');
     * A.connect(B);
     *
     * let learningRate = .3;
     * let momentum = 0;
     *
     * for(let i = 0; i &lt; 20000; i++)
     * {
     *   // when A activates 1
     *   A.activate(1);
     *
     *   // train B to activate 0
     *   B.activate();
     *   B.propagate(learningRate, momentum, true, 0);
     * }
     *
     * // test it
     * A.activate(1);
     * B.activate(); // 0.006540565760853365
     *
     * @see [Regularization Neataptic](https://wagenaartje.github.io/neataptic/docs/methods/regularization/)
     * @see [What is backpropagation | YouTube](https://www.youtube.com/watch?v=Ilg3gGewQ5U)
     */
    Node.prototype.propagate = function (target, options) {
        if (options === void 0) { options = {}; }
        options.momentum = Utils_1.getOrDefault(options.momentum, 0);
        options.rate = Utils_1.getOrDefault(options.rate, 0.3);
        options.update = Utils_1.getOrDefault(options.update, true);
        if (target !== undefined &amp;&amp; Number.isFinite(target)) {
            this.errorResponsibility = this.errorProjected = target - this.activation;
        }
        else {
            this.errorProjected = 0;
            for (var _i = 0, _a = this.outgoing; _i &lt; _a.length; _i++) {
                var connection = _a[_i];
                this.errorProjected += connection.to.errorResponsibility * connection.weight * connection.gain;
            }
            this.errorProjected *= this.derivativeState;
            this.errorGated = 0;
            for (var _b = 0, _c = this.gated; _b &lt; _c.length; _b++) { // for all connections gated by this node
                var connection = _c[_b];
                var influence = void 0;
                if (connection.to.selfConnection.gateNode === this) { // self connection is gated with this node
                    influence = connection.to.old + connection.weight * connection.from.activation;
                }
                else {
                    influence = connection.weight * connection.from.activation;
                }
                this.errorGated += connection.to.errorResponsibility * influence;
            }
            this.errorGated *= this.derivativeState;
            this.errorResponsibility = this.errorProjected + this.errorGated;
        }
        for (var _d = 0, _e = this.incoming; _d &lt; _e.length; _d++) {
            var connection = _e[_d];
            // calculate gradient
            var gradient = this.errorProjected * connection.eligibility;
            for (var j = 0; j &lt; connection.xTraceNodes.length; j++) {
                var node = connection.xTraceNodes[j];
                gradient += node.errorResponsibility * connection.xTraceValues[j];
            }
            connection.deltaWeightsTotal += options.rate * gradient * this.mask;
            if (options.update) {
                connection.deltaWeightsTotal += options.momentum * connection.deltaWeightsPrevious;
                connection.weight += connection.deltaWeightsTotal;
                connection.deltaWeightsPrevious = connection.deltaWeightsTotal;
                connection.deltaWeightsTotal = 0;
            }
        }
        this.deltaBiasTotal += options.rate * this.errorResponsibility;
        if (options.update) {
            this.deltaBiasTotal += options.momentum * this.deltaBiasPrevious;
            this.bias += this.deltaBiasTotal;
            this.deltaBiasPrevious = this.deltaBiasTotal;
            this.deltaBiasTotal = 0;
        }
    };
    /**
     * Actives the node.
     *
     * When a neuron activates, it computes its state from all its input connections and 'squashes' it using its activation function, and returns the output (activation).
     *
     * You can also provide the activation (a float between 0 and 1) as a parameter, which is useful for neurons in the input layer.
     *
     * @param [input] Environment signal (i.e. optional numerical value passed to the network as input)  - _should only be passed in input neurons_
     * @param [trace] Controls whether traces are created when activation happens (a trace is meta information left behind for different uses, e.g. backpropagation).
     *
     * @returns A neuron's ['Squashed'](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0) output value
     *
     * @example
     * let { Node } = require("@liquid-carrot/carrot");
     *
     * let A = new Node();
     * let B = new Node();
     *
     * A.connect(B);
     * A.activate(0.5); // 0.5
     * B.activate(); // 0.3244554645
     */
    Node.prototype.activate = function (input, trace) {
        var _this = this;
        if (trace === void 0) { trace = true; }
        if (input !== undefined) {
            return this.activation = input;
        }
        else if (this.isInputNode()) {
            throw new ReferenceError("There is no input given to an input node!");
        }
        if (trace) {
            this.old = this.state;
            this.state = this.selfConnection.gain * this.selfConnection.weight * this.state + this.bias;
            this.incoming.forEach(function (conn) {
                _this.state += conn.from.activation * conn.weight * conn.gain;
            });
            this.activation = this.squash.calc(this.state, false) * this.mask;
            this.derivativeState = this.squash.calc(this.state, true);
            // store traces
            var nodes_1 = [];
            var influences_1 = [];
            // Adjust 'gain' (to gated connections) &amp; Build traces
            this.gated.forEach(function (connection) {
                connection.gain = _this.activation;
                // Build traces
                var index = nodes_1.indexOf(connection.to);
                if (index > -1) { // Node &amp; influence exist
                    influences_1[index] += connection.weight * connection.from.activation;
                }
                else { // Add node &amp; corresponding influence
                    nodes_1.push(connection.to);
                    if (connection.to.selfConnection.gateNode === _this) {
                        influences_1.push(connection.weight * connection.from.activation + connection.to.old);
                    }
                    else {
                        influences_1.push(connection.weight * connection.from.activation);
                    }
                }
            });
            // Forwarding 'xTrace' (to incoming connections)
            for (var _i = 0, _a = this.incoming; _i &lt; _a.length; _i++) {
                var connection = _a[_i];
                connection.eligibility = this.selfConnection.gain * this.selfConnection.weight * connection.eligibility + connection.from.activation * connection.gain;
                for (var i = 0; i &lt; nodes_1.length; i++) {
                    var node = nodes_1[i];
                    var influence = influences_1[i];
                    var index = connection.xTraceNodes.indexOf(node);
                    if (index > -1) {
                        connection.xTraceValues[index] = node.selfConnection.gain * node.selfConnection.weight * connection.xTraceValues[index] + this.derivativeState * connection.eligibility * influence;
                    }
                    else {
                        connection.xTraceNodes.push(node);
                        connection.xTraceValues.push(this.derivativeState * connection.eligibility * influence);
                    }
                }
            }
            return this.activation;
        }
        else {
            if (this.isInputNode())
                return this.activation = 0;
            this.state = this.selfConnection.gain * this.selfConnection.weight * this.state + this.bias;
            for (var _b = 0, _c = this.incoming; _b &lt; _c.length; _b++) {
                var connection = _c[_b];
                this.state += connection.from.activation * connection.weight * connection.gain;
            }
            this.activation = this.squash.calc(this.state, false);
            // Adjust gain
            for (var _d = 0, _e = this.gated; _d &lt; _e.length; _d++) {
                var connection = _e[_d];
                connection.gain = this.activation;
            }
            return this.activation;
        }
    };
    /**
     * Converts the node to a json object that can later be converted back
     *
     * @returns A node representing json object
     *
     * @example
     * const { Node } = require("@liquid-carrot/carrot");
     *
     * let node = new Node();
     *
     * console.log(node.toJSON());
     */
    Node.prototype.toJSON = function () {
        return {
            bias: this.bias,
            type: this.type,
            squash: this.squash.type,
            mask: this.mask,
            index: this.index
        };
    };
    /**
     * Is this a input Node?
     */
    Node.prototype.isInputNode = function () {
        return this.type === NodeType_1.NodeType.INPUT;
    };
    /**
     * Is this a hidden Node?
     */
    Node.prototype.isHiddenNode = function () {
        return this.type === NodeType_1.NodeType.HIDDEN;
    };
    /**
     * Is this a output Node?
     */
    Node.prototype.isOutputNode = function () {
        return this.type === NodeType_1.NodeType.OUTPUT;
    };
    /**
     * Set bias.
     *
     * @param bias the new bias value
     */
    Node.prototype.setBias = function (bias) {
        this.bias = bias;
        return this;
    };
    /**
     * Set activation type
     *
     * @param activationType the new activation type
     */
    Node.prototype.setActivationType = function (activationType) {
        this.squash = Activation_1.Activation.getActivation(activationType);
        return this;
    };
    return Node;
}());
exports.Node = Node;
</code></pre>
        </article>
    </section>





            

        </div>
        <div class="column is-hidden-touch"></div>
    </div>
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.3</a> on Tue May 12 2020 21:51:13 GMT+0200 (GMT+02:00) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>
<script src="scripts/linenumber.js"></script>

<script src="scripts/jquery-3.1.1.min.js"></script>

<script src="scripts/search.js"></script>




<script type="text/javascript">
  window.heap=window.heap||[],heap.load=function(e,t){window.heap.appid=e,window.heap.config=t=t||{};var r=t.forceSSL||"https:"===document.location.protocol,a=document.createElement("script");a.type="text/javascript",a.async=!0,a.src=(r?"https:":"http:")+"//cdn.heapanalytics.com/js/heap-"+e+".js";var n=document.getElementsByTagName("script")[0];n.parentNode.insertBefore(a,n);for(var o=function(e){return function(){heap.push([e].concat(Array.prototype.slice.call(arguments,0)))}},p=["addEventProperties","addUserProperties","clearEventProperties","identify","resetIdentity","removeEventProperty","setEventProperties","track","unsetEventProperty"],c=0;c<p.length;c++)heap[p[c]]=o(p[c])};
  heap.load("1195922815");
</script>
<script>
document.addEventListener('DOMContentLoaded', () => {

  // Get all "navbar-burger" elements
  const $navbarBurgers = Array.prototype.slice.call(document.querySelectorAll('.navbar-burger'), 0);

  // Check if there are any navbar burgers
  if ($navbarBurgers.length > 0) {

    // Add a click event on each of them
    $navbarBurgers.forEach( el => {
      el.addEventListener('click', () => {

        // Get the target from the "data-target" attribute
        const target = el.dataset.target;
        const $target = document.getElementById(target);

        // Toggle the "is-active" class on both the "navbar-burger" and the "navbar-menu"
        el.classList.toggle('is-active');
        $target.classList.toggle('is-active');

      });
    });
  }

});
</script>
<script src="scripts/clipboard.min.js"></script>
<script>
  // example copying functionality
  const clipboard = new ClipboardJS('code');
  const clipboard_button = new ClipboardJS('.copy-button');

  clipboard_button.on('success', (e) => {
    e.trigger.innerText = "Copied!"
  });

  const copy_buttons = document.querySelectorAll(".copy-button");
  
  copy_buttons.forEach(function(btn) {
    btn.addEventListener("mouseout", function(e) {
      setTimeout(function() {
        e.fromElement.innerText = "Copy"
      }, 200);
    });
  });
</script>
<script>prettyPrint();</script>
</body>
</html>
