{"version":3,"sources":["../src/enums/ConnectionType.js","../src/enums/NodeType.js","../src/utils/Utils.js","../src/methods/Mutation.js","../src/architecture/Connection.js","../src/architecture/Node.js","../src/enums/GatingType.js","../src/architecture/Layers/Layer.js","../src/architecture/Nodes/ConstantNode.js","../src/architecture/Nodes/NoiseNode.js","../src/architecture/Layers/NoiseLayers/NoiseLayer.js","../src/architecture/Layers/CoreLayers/InputLayer.js","../src/architecture/Layers/CoreLayers/OutputLayer.js","../src/methods/Loss.js","../src/methods/Selection.js","../src/interfaces/EvolveOptions.js","../src/architecture/Species.js","../src/NEAT.js","../src/architecture/Network.js","../src/architecture/Architect.js","../src/architecture/Nodes/ActivationNode.js","../src/architecture/Layers/CoreLayers/ActivationLayer.js","../src/architecture/Layers/CoreLayers/DenseLayer.js","../src/architecture/Nodes/DropoutNode.js","../src/architecture/Layers/CoreLayers/DropoutLayer.js","../src/architecture/Nodes/PoolNode.js","../src/architecture/Layers/PoolingLayers/PoolingLayer.js","../src/architecture/Layers/PoolingLayers/AvgPooling1DLayer.js","../src/architecture/Layers/PoolingLayers/GlobalAvgPooling1DLayer.js","../src/architecture/Layers/PoolingLayers/MaxPooling1DLayer.js","../src/architecture/Layers/PoolingLayers/GlobalMaxPooling1DLayer.js","../src/architecture/Layers/PoolingLayers/MinPooling1DLayer.js","../src/architecture/Layers/PoolingLayers/GlobalMinPooling1DLayer.js","../src/architecture/Layers/RecurrentLayers/GRULayer.js","../src/architecture/Layers/RecurrentLayers/HopfieldLayer.js","../src/architecture/Layers/RecurrentLayers/LSTMLayer.js","../src/architecture/Layers/RecurrentLayers/MemoryLayer.js","../src/architecture/Layers/RecurrentLayers/RNNLayer.js","../src/methods/Rate.js","../src/interfaces/TrainOptions.js","index.js"],"names":["ConnectionType","Object","defineProperty","exports","value","NodeType","PoolNodeType","NoiseNodeType","pickRandom","arr","Array","isArray","length","RangeError","randInt","from","min","max","Math","floor","random","randDouble","randBoolean","removeFromArray","elem","index","indexOf","splice","shuffle","array","counter","temp","maxValue","i","maxValueIndex","minValueIndex","minValue","avg","sum","generateGaussian","mean","deviation","pairing","a","b","SwapNodesMutation","SubBackConnectionMutation","AddBackConnectionMutation","SubSelfConnectionMutation","AddSelfConnectionMutation","SubGateMutation","AddGateMutation","ModActivationMutation","ModBiasMutation","ModWeightMutation","SubConnectionMutation","AddConnectionMutation","SubNodeMutation","AddNodeMutation","Mutation","ONLY_STRUCTURE","NO_STRUCTURE_MUTATIONS","FEEDFORWARD_MUTATIONS","ALL_MUTATIONS","Node_1","require","NodeType_1","Utils_1","constructor","randomActivation","mutate","network","options","undefined","maxNodes","nodes","node","Node","HIDDEN","mutateActivation","connection","connections","to","disconnect","minBound","inputSize","newConnection1","connect","newConnection2","weight","gateNode","addGate","keepGates","possible","filter","isHiddenNode","removeNode","maxConnections","size","outputSize","j","isProjectingTo","push","pair","conn","outgoing","incoming","randomConnection","isInputNode","mutateBias","mutateOutput","allowedActivations","selfConnection","maxGates","gates","removeGate","node1","node2","biasTemp","bias","squashTemp","squash","Connection","gain","eligibility","deltaWeightsPrevious","deltaWeightsTotal","xTrace","Map","toJSON","fromIndex","toIndex","gateNodeIndex","getInnovationID","src_1","Mutation_1","Connection_1","type","Logistic","activation","derivativeState","state","old","mask","deltaBiasPrevious","deltaBiasTotal","Set","gated","errorResponsibility","errorProjected","errorGated","NaN","fromJSON","json","_a","_b","_c","_d","clear","forEach","method","values","ALL_ACTIVATIONS","isProjectedBy","map","includes","add","delete","target","twoSided","ReferenceError","Error","propagate","momentum","rate","update","Number","isFinite","influence","gradient","key","activate","input","trace","influences","has","set","get","INPUT","isOutputNode","OUTPUT","setBias","setActivationType","GatingType","Layer","ConnectionType_1","GatingType_1","inputNodes","outputNodes","connectionType","ALL_TO_ALL","NO_CONNECTION","fromNodes","toNodes","fromNode","toNode","ONE_TO_ONE","POOLING","ratio","gate","gateType","gatedConnections","SELF","ConstantNode","Identitiy","NoiseNode","ConstantNode_1","noiseType","GAUSSIAN_NOISE","incomingStates","gaussian","connectionsStates","NoiseLayer","NoiseNode_1","Layer_1","getDefaultIncomingConnectionType","connectionTypeisAllowed","InputLayer","NoiseLayer_1","noise","noiseLayer","OutputLayer","ALL_LOSSES","HINGELoss","MSLELoss","WAPELoss","MAPELoss","MAELoss","BinaryLoss","MBELoss","MSELoss","targets","outputs","error","pow","round","abs","log","__createBinding","create","o","m","k","k2","enumerable","__setModuleDefault","v","__importStar","mod","__esModule","result","hasOwnProperty","call","TournamentSelection","PowerSelection","FitnessProportionateSelection","Selection","TimSort","select","population","totalFitness","minimalFitness","genome","score","power","probability","individuals","sort","__importDefault","EvolveOptions","os_1","Network_1","Loss_1","Selection_1","_speciesDistanceThreshold","_c1","_c2","_c3","_survivors","_input","_output","_generation","_elitism","_equal","_clear","_populationSize","_mutationRate","_mutationAmount","_selection","_loss","_mutations","_activations","_template","Network","_maxNodes","Infinity","_maxConnections","_maxGates","_threads","default","cpus","_log","_iterations","_error","_maxStagnation","maxStagnation","speciesDistanceThreshold","c1","c2","c3","survivors","threads","output","dataset","_dataset","generation","training","_training","template","mutations","activations","selection","mutationRate","mutationAmount","elitism","populationSize","fitnessFunction","_fitnessFunction","loss","equal","schedule","_schedule","iterations","Species","representative","species","members","_score","lastScore","_stagnation","stagnation","put","distanceThreshold","distance","forcePut","evaluateScore","reset","kill","percentage","amount","breed","crossOver","getBest","networks","print","console","__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","step","next","e","rejected","adopt","done","then","apply","NEAT","Species_1","_options","copy","mutateRandom","allowed","name","evolve","genSpecies","evaluate","removeExtinctSpecies","reproduce","elitists","train","fittest","getFittest","getAverage","val","replacePopulation","genomes","speciesArr","selectedSpecies","member","killRate","found","threads_1","dist_1","EvolveOptions_1","NEAT_1","sqrt","nodeJSON","jsonConnection","network1","network2","offspring","score1","score2","offspringSize","chosenNode","chosenNodeType","sourceNetwork","inputNumber","outputNumber","newNode","n1connections","n2connections","keys1","keys","keys2","parseInt","connectionJSON","dropoutRate","inputs","shift","allowedMethods","start","Date","now","trainingSetSize","trainingSet","testSet","currentTrainingRate","crossValidateTestSize","ceil","slice","iterationCount","calc","trainEpoch","batchSize","trainingRate","dropout","test","function","time","entry","workerPool","serializedDataSet","JSON","stringify","lossIndex","Pool","spawn","Worker","queue","completed","neat","bestFitness","bestGenome","terminate","g2","g1","indexG1","indexG2","connections1","connections2","highestInnovationID1","disjointGenes","totalWeightDiff","similarGenes","gene1","gene2","excessGenes","N","errorSum","correctOutput","Architect","InputLayer_1","OutputLayer_1","layers","addLayer","layer","incomingConnectionType","buildModel","ActivationNode","ActivationLayer","ActivationNode_1","DenseLayer","activationType","DropoutNode","droppedOut","incomingConnection","assign","DropoutLayer","DropoutNode_1","PoolNode","poolingType","MAX_POOLING","receivingNode","poolType","AVG_POOLING","MIN_POOLING","PoolingLayer","AvgPooling1DLayer","PoolNode_1","PoolingLayer_1","GlobalAvgPooling1DLayer","AvgPooling1DLayer_1","MaxPooling1DLayer","GlobalMaxPooling1DLayer","MaxPooling1DLayer_1","MinPooling1DLayer","GlobalMinPooling1DLayer","MinPooling1DLayer_1","GRULayer","updateGate","inverseUpdateGate","resetGate","memoryCell","previousOutput","TANH","inverseUpdate","HopfieldLayer","BinaryStep","LSTMLayer","inputGate","forgetGate","outputGate","forgetGateConnections","outputGateConnections","inputGateConnections","MemoryLayer","prevNodes","memorySize","block","reverse","RNNLayer","InverseRate","ExponentialRate","StepRate","FixedRate","Rate","baseRate","iteration","gamma","stepSize","TrainOptions","Rate_1","_dropout","_momentum","_batchSize","_rate","_crossValidateTestSize","_shuffle","Architect_1","ActivationLayer_1","DenseLayer_1","DropoutLayer_1","GlobalAvgPooling1DLayer_1","GlobalMaxPooling1DLayer_1","GlobalMinPooling1DLayer_1","GRULayer_1","HopfieldLayer_1","LSTMLayer_1","MemoryLayer_1","RNNLayer_1","TrainOptions_1"],"mappings":"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","file":"index.browser.min.js","sourceRoot":"..\\..\\build\\scripts","sourcesContent":["\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ConnectionType = void 0;\r\n/**\r\n * The type of a connection.\r\n */\r\nvar ConnectionType;\r\n(function (ConnectionType) {\r\n    /**\r\n     * No connection used for exceptions.\r\n     */\r\n    ConnectionType[ConnectionType[\"NO_CONNECTION\"] = 0] = \"NO_CONNECTION\";\r\n    /**\r\n     * Connect all input to all output nodes\r\n     */\r\n    ConnectionType[ConnectionType[\"ALL_TO_ALL\"] = 1] = \"ALL_TO_ALL\";\r\n    /**\r\n     * Connect one input to one output node\r\n     */\r\n    ConnectionType[ConnectionType[\"ONE_TO_ONE\"] = 2] = \"ONE_TO_ONE\";\r\n    /**\r\n     * Connect with pooling\r\n     */\r\n    ConnectionType[ConnectionType[\"POOLING\"] = 3] = \"POOLING\";\r\n})(ConnectionType = exports.ConnectionType || (exports.ConnectionType = {}));\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NoiseNodeType = exports.PoolNodeType = exports.NodeType = void 0;\r\n/**\r\n * The type of node.\r\n */\r\nvar NodeType;\r\n(function (NodeType) {\r\n    /**\r\n     * Node is an input node.\r\n     */\r\n    NodeType[NodeType[\"INPUT\"] = 0] = \"INPUT\";\r\n    /**\r\n     * Node is a hidden node.\r\n     */\r\n    NodeType[NodeType[\"HIDDEN\"] = 1] = \"HIDDEN\";\r\n    /**\r\n     * Node is a output node.\r\n     */\r\n    NodeType[NodeType[\"OUTPUT\"] = 2] = \"OUTPUT\";\r\n})(NodeType = exports.NodeType || (exports.NodeType = {}));\r\n/**\r\n * The type of pool node.\r\n */\r\nvar PoolNodeType;\r\n(function (PoolNodeType) {\r\n    /**\r\n     * Maximum pooling node.\r\n     */\r\n    PoolNodeType[PoolNodeType[\"MAX_POOLING\"] = 0] = \"MAX_POOLING\";\r\n    /**\r\n     * Average pooling node.\r\n     */\r\n    PoolNodeType[PoolNodeType[\"AVG_POOLING\"] = 1] = \"AVG_POOLING\";\r\n    /**\r\n     * Minimum pooling node.\r\n     */\r\n    PoolNodeType[PoolNodeType[\"MIN_POOLING\"] = 2] = \"MIN_POOLING\";\r\n})(PoolNodeType = exports.PoolNodeType || (exports.PoolNodeType = {}));\r\n/**\r\n * The type of noise node.\r\n */\r\nvar NoiseNodeType;\r\n(function (NoiseNodeType) {\r\n    /**\r\n     * Gaussian noise node\r\n     */\r\n    NoiseNodeType[NoiseNodeType[\"GAUSSIAN_NOISE\"] = 0] = \"GAUSSIAN_NOISE\";\r\n})(NoiseNodeType = exports.NoiseNodeType || (exports.NoiseNodeType = {}));\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.pairing = exports.generateGaussian = exports.avg = exports.sum = exports.min = exports.minValueIndex = exports.maxValueIndex = exports.max = exports.shuffle = exports.removeFromArray = exports.randBoolean = exports.randDouble = exports.randInt = exports.pickRandom = void 0;\r\n/**\r\n * Returns an random element from the given array.\r\n *\r\n * @param arr the array to pick from\r\n * @returns the random picked element\r\n */\r\nfunction pickRandom(arr) {\r\n    if (Array.isArray(arr)) {\r\n        if (arr.length === 0) {\r\n            throw new RangeError(\"Cannot pick from an empty array\");\r\n        }\r\n        return arr[randInt(0, arr.length)];\r\n    }\r\n    else {\r\n        return pickRandom(Array.from(arr));\r\n    }\r\n}\r\nexports.pickRandom = pickRandom;\r\n/**\r\n * Returns a random integer in the range [min,max)\r\n *\r\n * @param min bound\r\n * @param max bound\r\n * @returns random integer in [min,max)\r\n */\r\nfunction randInt(min, max) {\r\n    return Math.floor(Math.random() * (max - min) + min);\r\n}\r\nexports.randInt = randInt;\r\n/**\r\n * Returns a random double in the range [min,max)\r\n *\r\n * @param min bound\r\n * @param max bound\r\n * @returns random double in [min,max)\r\n */\r\nfunction randDouble(min, max) {\r\n    return Math.random() * (max - min) + min;\r\n}\r\nexports.randDouble = randDouble;\r\n/**\r\n * Returns a random boolean\r\n *\r\n * @returns random boolean\r\n */\r\nfunction randBoolean() {\r\n    return Math.random() >= 0.5;\r\n}\r\nexports.randBoolean = randBoolean;\r\n/**\r\n * Removes an element from an array.\r\n *\r\n * @param arr the array\r\n * @param elem the element which will be removed\r\n * @returns false -> element does not exists on array; true -> element removed from array\r\n */\r\nfunction removeFromArray(arr, elem) {\r\n    const index = arr.indexOf(elem);\r\n    if (index === -1) {\r\n        return false;\r\n    }\r\n    else {\r\n        arr.splice(index, 1);\r\n        return true;\r\n    }\r\n}\r\nexports.removeFromArray = removeFromArray;\r\n/**\r\n * Shuffles an array\r\n * @param array the array\r\n * @returns the shuffled array\r\n */\r\nfunction shuffle(array) {\r\n    // While there are elements in the array\r\n    for (let counter = array.length - 1; counter > 0; counter--) {\r\n        // Pick a random index\r\n        const index = randInt(0, counter);\r\n        // And swap the last element with it\r\n        const temp = array[counter];\r\n        array[counter] = array[index];\r\n        array[index] = temp;\r\n    }\r\n}\r\nexports.shuffle = shuffle;\r\n/**\r\n * Finds the maximum value of an number array\r\n *\r\n * @param array\r\n */\r\nfunction max(array) {\r\n    if (array.length === 0) {\r\n        throw new RangeError();\r\n    }\r\n    let maxValue = array[0];\r\n    for (let i = 1; i < array.length; i++) {\r\n        if (array[i] > maxValue) {\r\n            maxValue = array[i];\r\n        }\r\n    }\r\n    return maxValue;\r\n}\r\nexports.max = max;\r\n/**\r\n * Finds the maximum value index of an number array\r\n *\r\n * @param array\r\n */\r\nfunction maxValueIndex(array) {\r\n    if (array.length === 0) {\r\n        throw new RangeError();\r\n    }\r\n    let maxValue = array[0];\r\n    let maxValueIndex = 0;\r\n    for (let i = 1; i < array.length; i++) {\r\n        if (array[i] > maxValue) {\r\n            maxValue = array[i];\r\n            maxValueIndex = i;\r\n        }\r\n    }\r\n    return maxValueIndex;\r\n}\r\nexports.maxValueIndex = maxValueIndex;\r\n/**\r\n * Finds the minimum value index of an number array\r\n *\r\n * @param array\r\n */\r\nfunction minValueIndex(array) {\r\n    if (array.length === 0) {\r\n        throw new RangeError();\r\n    }\r\n    let minValue = array[0];\r\n    let minValueIndex = 0;\r\n    for (let i = 1; i < array.length; i++) {\r\n        if (array[i] < minValue) {\r\n            minValue = array[i];\r\n            minValueIndex = i;\r\n        }\r\n    }\r\n    return minValueIndex;\r\n}\r\nexports.minValueIndex = minValueIndex;\r\n/**\r\n * Finds the minimum value of an number array\r\n *\r\n * @param array\r\n */\r\nfunction min(array) {\r\n    if (array.length === 0) {\r\n        throw new RangeError();\r\n    }\r\n    let minValue = array[0];\r\n    for (let i = 1; i < array.length; i++) {\r\n        if (array[i] < minValue) {\r\n            minValue = array[i];\r\n        }\r\n    }\r\n    return minValue;\r\n}\r\nexports.min = min;\r\n/**\r\n * Calculates the average value of an array\r\n *\r\n * @param array\r\n */\r\nfunction avg(array) {\r\n    return sum(array) / array.length;\r\n}\r\nexports.avg = avg;\r\n/**\r\n * Calculates the sum of all values of an array\r\n *\r\n * @param array\r\n */\r\nfunction sum(array) {\r\n    if (array.length === 0) {\r\n        throw new RangeError();\r\n    }\r\n    let sum = 0;\r\n    for (const value of array) {\r\n        sum += value;\r\n    }\r\n    return sum;\r\n}\r\nexports.sum = sum;\r\n/**\r\n * Generates a random number with the gaussian distribution.\r\n *\r\n * @see https://en.wikipedia.org/wiki/Normal_distribution\r\n *\r\n * @param mean the mean value\r\n * @param deviation the standard deviation\r\n */\r\nfunction generateGaussian(mean = 0, deviation = 2) {\r\n    let sum = 0;\r\n    const numSamples = 10;\r\n    for (let i = 0; i < numSamples; i++) {\r\n        sum += Math.random();\r\n    }\r\n    return deviation * sum / numSamples + mean - 0.5 * deviation;\r\n}\r\nexports.generateGaussian = generateGaussian;\r\n/**\r\n * Pairing two numbers\r\n *\r\n * @see {@link https://en.wikipedia.org/wiki/Pairing_function (Cantor pairing function)|Pairing function (Cantor pairing function)}\r\n *\r\n * @param a - A [natural number](https://en.wikipedia.org/wiki/Natural_number), which is an integer greater than or equal to zero\r\n * @param b - A [natural number](https://en.wikipedia.org/wiki/Natural_number), which is an integer greater than or equal to zero\r\n *\r\n * @return An Integer that uniquely represents a pair of Integers\r\n */\r\nfunction pairing(a, b) {\r\n    return 1 / 2 * (a + b) * (a + b + 1) + b;\r\n}\r\nexports.pairing = pairing;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.SwapNodesMutation = exports.SubBackConnectionMutation = exports.AddBackConnectionMutation = exports.SubSelfConnectionMutation = exports.AddSelfConnectionMutation = exports.SubGateMutation = exports.AddGateMutation = exports.ModActivationMutation = exports.ModBiasMutation = exports.ModWeightMutation = exports.SubConnectionMutation = exports.AddConnectionMutation = exports.SubNodeMutation = exports.AddNodeMutation = exports.Mutation = exports.ONLY_STRUCTURE = exports.NO_STRUCTURE_MUTATIONS = exports.FEEDFORWARD_MUTATIONS = exports.ALL_MUTATIONS = void 0;\r\nconst Node_1 = require(\"../architecture/Node\");\r\nconst NodeType_1 = require(\"../enums/NodeType\");\r\nconst Utils_1 = require(\"../utils/Utils\");\r\n/**\r\n *\r\n * Genetic algorithm mutation methods. Creates variations (mutations) in neural networks which are then selected for better performance.\r\n *\r\n * @see {@link https://en.wikipedia.org/wiki/mutation_(genetic_algorithm)|Mutation (genetic algorithms) on Wikipedia}\r\n * @see {@link https://en.wikipedia.org/wiki/Genetic_algorithm#Selection|Selection (genetic algorithms) on Wikipedia}\r\n */\r\nclass Mutation {\r\n}\r\nexports.Mutation = Mutation;\r\n/**\r\n * Add node mutation.\r\n *\r\n * Adds a hidden node to the network.\r\n */\r\nclass AddNodeMutation extends Mutation {\r\n    /**\r\n     * Constructs a AddNodeMutation object\r\n     * @param randomActivation Should choose a random activation for a new node?\r\n     */\r\n    constructor(randomActivation = true) {\r\n        super();\r\n        this.randomActivation = randomActivation;\r\n    }\r\n    /**\r\n     * Mutates the network.\r\n     *\r\n     * @param network The network which gets mutated\r\n     * @param options\r\n     */\r\n    mutate(network, options = {}) {\r\n        // check if max nodes is already reached\r\n        if (options.maxNodes !== undefined && network.nodes.length >= options.maxNodes) {\r\n            return;\r\n        }\r\n        // create a new hidden node\r\n        const node = new Node_1.Node(NodeType_1.NodeType.HIDDEN);\r\n        if (this.randomActivation) {\r\n            node.mutateActivation(); // choose random activation\r\n        }\r\n        // take a random connection\r\n        const connection = Utils_1.pickRandom(Array.from(network.connections));\r\n        const from = connection.from;\r\n        const to = connection.to;\r\n        network.disconnect(from, to); // disconnect it\r\n        // put the node in between the connection\r\n        const minBound = Math.max(network.inputSize, 1 + network.nodes.indexOf(from));\r\n        network.nodes.splice(minBound, 0, node);\r\n        const newConnection1 = network.connect(from, node, 1);\r\n        const newConnection2 = network.connect(node, to, connection.weight);\r\n        if (connection.gateNode != null) {\r\n            // if connection had a gate node\r\n            // choose randomly which new connection should get this gate node\r\n            if (Utils_1.randBoolean()) {\r\n                network.addGate(connection.gateNode, newConnection1);\r\n            }\r\n            else {\r\n                network.addGate(connection.gateNode, newConnection2);\r\n            }\r\n        }\r\n    }\r\n}\r\nexports.AddNodeMutation = AddNodeMutation;\r\n/**\r\n * Sub node mutation.\r\n *\r\n * Removes a random node from the network.\r\n */\r\nclass SubNodeMutation extends Mutation {\r\n    constructor(keepGates = true) {\r\n        super();\r\n        this.keepGates = keepGates;\r\n    }\r\n    /**\r\n     * Mutates the network.\r\n     *\r\n     * @param network The network which gets mutated\r\n     */\r\n    mutate(network) {\r\n        const possible = network.nodes.filter(node => node !== undefined && node.isHiddenNode()); // hidden nodes\r\n        if (possible.length > 0) {\r\n            network.removeNode(Utils_1.pickRandom(possible), this.keepGates); // remove a random node from the filtered array\r\n        }\r\n    }\r\n}\r\nexports.SubNodeMutation = SubNodeMutation;\r\n/**\r\n * Add connections mutation.\r\n *\r\n * Adds a connection to the network.\r\n */\r\nclass AddConnectionMutation extends Mutation {\r\n    /**\r\n     * Mutates the network.\r\n     *\r\n     * @param network The network which gets mutated\r\n     * @param options\r\n     */\r\n    mutate(network, options = {}) {\r\n        // check if max connections is already reached\r\n        if (options.maxConnections !== undefined && network.connections.size >= options.maxConnections) {\r\n            return;\r\n        }\r\n        const possible = [];\r\n        for (let i = 0; i < network.nodes.length - network.outputSize; i++) {\r\n            const from = network.nodes[i];\r\n            for (let j = Math.max(i + 1, network.inputSize); j < network.nodes.length; j++) {\r\n                const to = network.nodes[j];\r\n                if (!from.isProjectingTo(to)) {\r\n                    possible.push([from, to]);\r\n                }\r\n            }\r\n        }\r\n        if (possible.length > 0) {\r\n            const pair = Utils_1.pickRandom(possible);\r\n            network.connect(pair[0], pair[1]);\r\n        }\r\n    }\r\n}\r\nexports.AddConnectionMutation = AddConnectionMutation;\r\n/**\r\n * Sub connection mutation.\r\n *\r\n * Removes a random connection from the network.\r\n */\r\nclass SubConnectionMutation extends Mutation {\r\n    /**\r\n     * Mutates the network.\r\n     *\r\n     * @param network The network which gets mutated\r\n     */\r\n    mutate(network) {\r\n        const possible = Array.from(network.connections)\r\n            .filter(conn => conn.from.outgoing.size > 1) // do not deactivate a neuron\r\n            .filter(conn => conn.to.incoming.size > 1) // do not deactivate a neuron\r\n            .filter(conn => network.nodes.indexOf(conn.to) > network.nodes.indexOf(conn.from)); // look for forward pointing connections\r\n        if (possible.length > 0) {\r\n            const randomConnection = Utils_1.pickRandom(possible); // pick a random connection from the filtered array\r\n            network.disconnect(randomConnection.from, randomConnection.to); // remove the connection from the network\r\n        }\r\n    }\r\n}\r\nexports.SubConnectionMutation = SubConnectionMutation;\r\n/**\r\n * Mod weight mutation.\r\n *\r\n * Modifies the weight of a random connection.\r\n */\r\nclass ModWeightMutation extends Mutation {\r\n    /**\r\n     * Constructs a ModWeightMutation object\r\n     * @param min The minimum weight.\r\n     * @param max The maximum weight.\r\n     */\r\n    constructor(min = -1, max = 1) {\r\n        super();\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    /**\r\n     * Mutates the network.\r\n     *\r\n     * @param network The network which gets mutated\r\n     */\r\n    mutate(network) {\r\n        // pick random connection and mutate it's weight\r\n        Utils_1.pickRandom(Array.from(network.connections)).weight += Utils_1.randDouble(this.min, this.max);\r\n    }\r\n}\r\nexports.ModWeightMutation = ModWeightMutation;\r\n/**\r\n * Mod bias mutation.\r\n *\r\n * Modifies the bias value of a random hidden or output node\r\n */\r\nclass ModBiasMutation extends Mutation {\r\n    /**\r\n     * Constructs a ModBiasMutation object\r\n     * @param min The minimum bias.\r\n     * @param max The maximum bias.\r\n     */\r\n    constructor(min = -1, max = 1) {\r\n        super();\r\n        this.min = min;\r\n        this.max = max;\r\n    }\r\n    /**\r\n     * Mutates the network.\r\n     *\r\n     * @param network The network which gets mutated\r\n     */\r\n    mutate(network) {\r\n        Utils_1.pickRandom(network.nodes.filter(node => !node.isInputNode())) // pick random hidden or output node\r\n            .mutateBias(this); // mutate it's bias\r\n    }\r\n}\r\nexports.ModBiasMutation = ModBiasMutation;\r\n/**\r\n * Mod activation mutation.\r\n *\r\n * Modifies the activation function of a random node\r\n */\r\nclass ModActivationMutation extends Mutation {\r\n    /**\r\n     * Constructs a ModActivationMutation object\r\n     * @param mutateOutput Can the output be mutated?\r\n     */\r\n    constructor(mutateOutput = false) {\r\n        super();\r\n        this.mutateOutput = mutateOutput;\r\n    }\r\n    /**\r\n     * Mutates the network.\r\n     *\r\n     * @param network The network which gets mutated\r\n     * @param options\r\n     */\r\n    mutate(network, options = {}) {\r\n        const possible = this.mutateOutput\r\n            ? network.nodes.filter(node => !node.isInputNode()) // hidden and output nodes\r\n            : network.nodes.filter(node => node.isHiddenNode()); // hidden nodes\r\n        if (possible.length > 0) {\r\n            Utils_1.pickRandom(possible).mutateActivation(options.allowedActivations); // mutate the activation of the node\r\n        }\r\n    }\r\n}\r\nexports.ModActivationMutation = ModActivationMutation;\r\n/**\r\n * Add self connection.\r\n *\r\n * Adds a connection from a node to itself.\r\n */\r\nclass AddSelfConnectionMutation extends Mutation {\r\n    /**\r\n     * Mutates the network.\r\n     *\r\n     * @param network The network which gets mutated\r\n     */\r\n    mutate(network) {\r\n        const possible = network.nodes\r\n            .filter(node => !node.isInputNode()) // no input nodes\r\n            .filter(node => node.selfConnection.weight === 0); // only nodes that doesn't have an self connection already\r\n        if (possible.length > 0) {\r\n            const node = Utils_1.pickRandom(possible); // pick a random node from the filtered array\r\n            network.connect(node, node); // connection the node to itself\r\n        }\r\n    }\r\n}\r\nexports.AddSelfConnectionMutation = AddSelfConnectionMutation;\r\n/**\r\n * Sub self connection.\r\n *\r\n * Removes a connection from a node to itself.\r\n */\r\nclass SubSelfConnectionMutation extends Mutation {\r\n    /**\r\n     * Mutates the network.\r\n     *\r\n     * @param network The network which gets mutated\r\n     */\r\n    mutate(network) {\r\n        const possible = Array.from(network.connections).filter(conn => conn.from === conn.to);\r\n        if (possible.length > 0) {\r\n            const randomConnection = Utils_1.pickRandom(possible);\r\n            network.disconnect(randomConnection.from, randomConnection.to);\r\n        }\r\n    }\r\n}\r\nexports.SubSelfConnectionMutation = SubSelfConnectionMutation;\r\n/**\r\n * Add gate mutation.\r\n *\r\n * Adds a gate to the network.\r\n */\r\nclass AddGateMutation extends Mutation {\r\n    /**\r\n     * Mutates the network.\r\n     *\r\n     * @param network The network which gets mutated\r\n     * @param options\r\n     */\r\n    mutate(network, options = {}) {\r\n        // check if max gates isn't reached already\r\n        if (options.maxGates !== undefined && network.gates.size >= options.maxGates) {\r\n            return;\r\n        }\r\n        // use only connections that aren't already gated\r\n        const possible = Array.from(network.connections).filter(conn => conn.gateNode === null);\r\n        if (possible.length > 0) {\r\n            const node = Utils_1.pickRandom(network.nodes.filter(node => !node.isInputNode())); // hidden or output node\r\n            const connection = Utils_1.pickRandom(possible); // random connection from filtered array\r\n            network.addGate(node, connection); // use the node to gate the connection\r\n        }\r\n    }\r\n}\r\nexports.AddGateMutation = AddGateMutation;\r\n/**\r\n * Sub gate mutation.\r\n *\r\n * Removes a gate from the network.\r\n */\r\nclass SubGateMutation extends Mutation {\r\n    /**\r\n     * Mutates the network.\r\n     *\r\n     * @param network The network which gets mutated\r\n     */\r\n    mutate(network) {\r\n        if (network.gates.size > 0) {\r\n            network.removeGate(Utils_1.pickRandom(Array.from(network.gates)));\r\n        }\r\n    }\r\n}\r\nexports.SubGateMutation = SubGateMutation;\r\n/**\r\n * Add back connection mutation.\r\n *\r\n * Adds a backward pointing connection to the network.\r\n */\r\nclass AddBackConnectionMutation extends Mutation {\r\n    /**\r\n     * Mutates the network.\r\n     *\r\n     * @param network The network which gets mutated\r\n     */\r\n    mutate(network) {\r\n        const possible = [];\r\n        for (let i = network.inputSize; i < network.nodes.length; i++) {\r\n            const from = network.nodes[i];\r\n            for (let j = network.inputSize; j < i; j++) {\r\n                const to = network.nodes[j];\r\n                if (!from.isProjectingTo(to)) {\r\n                    possible.push([from, to]);\r\n                }\r\n            }\r\n        }\r\n        if (possible.length > 0) {\r\n            const pair = Utils_1.pickRandom(possible);\r\n            network.connect(pair[0], pair[1]);\r\n        }\r\n    }\r\n}\r\nexports.AddBackConnectionMutation = AddBackConnectionMutation;\r\n/**\r\n * Sub back connection mutation.\r\n *\r\n * Removes a backward pointing connection to the network.\r\n */\r\nclass SubBackConnectionMutation extends Mutation {\r\n    /**\r\n     * Mutates the network.\r\n     *\r\n     * @param network The network which gets mutated\r\n     */\r\n    mutate(network) {\r\n        const possible = Array.from(network.connections)\r\n            .filter(conn => conn.from.outgoing.size > 1)\r\n            .filter(conn => conn.to.incoming.size > 1)\r\n            .filter(conn => network.nodes.indexOf(conn.from) > network.nodes.indexOf(conn.to));\r\n        if (possible.length > 0) {\r\n            const randomConnection = Utils_1.pickRandom(possible);\r\n            network.disconnect(randomConnection.from, randomConnection.to);\r\n        }\r\n    }\r\n}\r\nexports.SubBackConnectionMutation = SubBackConnectionMutation;\r\n/**\r\n * Swap nodes mutation.\r\n *\r\n * Swaps the values of two randomly picked nodes.\r\n */\r\nclass SwapNodesMutation extends Mutation {\r\n    /**\r\n     * Constructs a SwapNodeMutation object\r\n     * @param mutateOutput Can the output be mutated?\r\n     */\r\n    constructor(mutateOutput = false) {\r\n        super();\r\n        this.mutateOutput = mutateOutput;\r\n    }\r\n    /**\r\n     * Mutates the network.\r\n     *\r\n     * @param network The network which gets mutated\r\n     */\r\n    mutate(network) {\r\n        const possible = this.mutateOutput\r\n            ? network.nodes.filter(node => node !== undefined && !node.isInputNode()) // hidden or output nodes\r\n            : network.nodes.filter(node => node !== undefined && node.isHiddenNode()); // only hidden nodes\r\n        if (possible.length >= 2) {\r\n            // select two different nodes from the filtered array\r\n            const node1 = Utils_1.pickRandom(possible);\r\n            const node2 = Utils_1.pickRandom(possible.filter(node => node !== node1));\r\n            // change there parameters\r\n            const biasTemp = node1.bias;\r\n            const squashTemp = node1.squash;\r\n            node1.bias = node2.bias;\r\n            node1.squash = node2.squash;\r\n            node2.bias = biasTemp;\r\n            node2.squash = squashTemp;\r\n        }\r\n    }\r\n}\r\nexports.SwapNodesMutation = SwapNodesMutation;\r\n/**\r\n * Array of all mutation methods\r\n */\r\nconst ALL_MUTATIONS = [\r\n    new AddNodeMutation(),\r\n    new SubNodeMutation(),\r\n    new AddConnectionMutation(),\r\n    new SubConnectionMutation(),\r\n    new ModWeightMutation(),\r\n    new ModBiasMutation(),\r\n    new ModActivationMutation(),\r\n    new AddGateMutation(),\r\n    new SubGateMutation(),\r\n    new AddSelfConnectionMutation(),\r\n    new SubSelfConnectionMutation(),\r\n    new AddBackConnectionMutation(),\r\n    new SubBackConnectionMutation(),\r\n    new SwapNodesMutation(),\r\n];\r\nexports.ALL_MUTATIONS = ALL_MUTATIONS;\r\n/**\r\n * Array of all feed forward mutation methods\r\n */\r\nconst FEEDFORWARD_MUTATIONS = [\r\n    new AddNodeMutation(),\r\n    new SubNodeMutation(),\r\n    new AddConnectionMutation(),\r\n    new SubConnectionMutation(),\r\n    new ModWeightMutation(),\r\n    new ModBiasMutation(),\r\n    new ModActivationMutation(),\r\n    new SwapNodesMutation(),\r\n];\r\nexports.FEEDFORWARD_MUTATIONS = FEEDFORWARD_MUTATIONS;\r\nconst NO_STRUCTURE_MUTATIONS = [\r\n    new ModWeightMutation(),\r\n    new ModBiasMutation(),\r\n    new ModActivationMutation(),\r\n];\r\nexports.NO_STRUCTURE_MUTATIONS = NO_STRUCTURE_MUTATIONS;\r\nconst ONLY_STRUCTURE = [\r\n    new AddNodeMutation(),\r\n    new SubNodeMutation(),\r\n    new AddConnectionMutation(),\r\n    new SubConnectionMutation(),\r\n    new AddGateMutation(),\r\n    new SubGateMutation(),\r\n    new AddSelfConnectionMutation(),\r\n    new SubSelfConnectionMutation(),\r\n    new AddBackConnectionMutation(),\r\n    new SubBackConnectionMutation(),\r\n    new SwapNodesMutation(),\r\n];\r\nexports.ONLY_STRUCTURE = ONLY_STRUCTURE;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Connection = void 0;\r\nconst Utils_1 = require(\"../utils/Utils\");\r\n/**\r\n * A connection instance describes the connection between two nodes.\r\n */\r\nclass Connection {\r\n    constructor(from, to, weight, gateNode) {\r\n        this.from = from;\r\n        this.to = to;\r\n        this.weight = weight !== null && weight !== void 0 ? weight : 0;\r\n        this.gain = 1;\r\n        this.eligibility = 0;\r\n        this.deltaWeightsPrevious = 0;\r\n        this.deltaWeightsTotal = 0;\r\n        this.xTrace = new Map();\r\n        if (gateNode) {\r\n            this.gateNode = gateNode;\r\n            gateNode.addGate(this);\r\n        }\r\n        else {\r\n            this.gateNode = null;\r\n        }\r\n    }\r\n    /**\r\n     * Returns the connection as a JSON\r\n     *\r\n     * @return Connection as a JSON\r\n     */\r\n    toJSON() {\r\n        return {\r\n            fromIndex: this.from.index,\r\n            toIndex: this.to.index,\r\n            gateNodeIndex: this.gateNode === null ? null : this.gateNode.index,\r\n            weight: this.weight\r\n        };\r\n    }\r\n    /**\r\n     * Get the innovation ID for this connection\r\n     */\r\n    getInnovationID() {\r\n        return Utils_1.pairing(this.from.index, this.to.index);\r\n    }\r\n}\r\nexports.Connection = Connection;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Node = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst NodeType_1 = require(\"../enums/NodeType\");\r\nconst Mutation_1 = require(\"../methods/Mutation\");\r\nconst Utils_1 = require(\"../utils/Utils\");\r\nconst Connection_1 = require(\"./Connection\");\r\n/**\r\n * Creates a new neuron/node\r\n *\r\n * Neurons are the basic unit of the neural network. They can be connected together, or used to gate connections between other neurons. A Neuron can perform basically 4 operations: form connections, gate connections, activate and [propagate](https://www.youtube.com/watch?v=Ilg3gGewQ5U).\r\n *\r\n * For more information check:\r\n * - [BecomingHuman](https://becominghuman.ai/what-is-an-artificial-neuron-8b2e421ce42e)\r\n * - [Wikipedia](https://en.wikipedia.org/wiki/Artificial_neuron)\r\n * - [Neataptic](https://wagenaartje.github.io/neataptic/docs/architecture/node/)\r\n * - [Synaptic](https://github.com/cazala/synaptic/wiki/Neural-Networks-101)\r\n * - [Keras](https://keras.io/backend/#bias_add)\r\n */\r\nclass Node {\r\n    constructor(type = NodeType_1.NodeType.HIDDEN) {\r\n        this.type = type;\r\n        this.bias = Utils_1.randDouble(-1, 1);\r\n        this.squash = src_1.Logistic;\r\n        this.activation = 0;\r\n        this.derivativeState = 1;\r\n        this.state = 0;\r\n        this.old = 0;\r\n        this.mask = 1;\r\n        this.deltaBiasPrevious = 0;\r\n        this.deltaBiasTotal = 0;\r\n        this.incoming = new Set();\r\n        this.outgoing = new Set();\r\n        this.gated = new Set();\r\n        this.selfConnection = new Connection_1.Connection(this, this, 0);\r\n        this.errorResponsibility = 0;\r\n        this.errorProjected = 0;\r\n        this.errorGated = 0;\r\n        this.index = NaN;\r\n    }\r\n    /**\r\n     * Convert a json object to a node\r\n     *\r\n     * @param json A node represented as a JSON object\r\n     *\r\n     * @returns itself\r\n     */\r\n    fromJSON(json) {\r\n        var _a, _b, _c, _d;\r\n        this.bias = (_a = json.bias) !== null && _a !== void 0 ? _a : Utils_1.randDouble(-1, 1);\r\n        this.type = json.type;\r\n        this.squash = (_b = json.squash) !== null && _b !== void 0 ? _b : src_1.Logistic;\r\n        this.mask = (_c = json.mask) !== null && _c !== void 0 ? _c : 1;\r\n        this.index = (_d = json.index) !== null && _d !== void 0 ? _d : NaN;\r\n        return this;\r\n    }\r\n    /**\r\n     * Clears this node's state information - _i.e. resets node and its connections to \"factory settings\"_\r\n     *\r\n     * `node.clear()` is useful for predicting time series.\r\n     */\r\n    clear() {\r\n        this.incoming.forEach(connection => {\r\n            connection.eligibility = 0;\r\n            connection.xTrace.clear();\r\n        });\r\n        this.gated.forEach(conn => conn.gain = 0);\r\n        this.errorResponsibility = this.errorProjected = this.errorGated = 0;\r\n        this.old = this.state = this.activation = 0;\r\n    }\r\n    /**\r\n     * Mutates the node's bias\r\n     *\r\n     * @param method The method is needed for the min and max value of the node's bias otherwise a range of [-1,1] is chosen\r\n     */\r\n    mutateBias(method = new Mutation_1.ModBiasMutation()) {\r\n        this.bias += Utils_1.randDouble(method.min, method.max); // add a random value in range [min,max)\r\n    }\r\n    /**\r\n     * Mutates the node's activation function\r\n     */\r\n    mutateActivation(allowedActivations = Object.values(src_1.ALL_ACTIVATIONS)) {\r\n        // pick a random activation from allowed activations except the current activation\r\n        const possible = allowedActivations.filter(activation => activation !== this.squash);\r\n        if (possible.length > 0) {\r\n            this.squash = Utils_1.pickRandom(possible);\r\n        }\r\n    }\r\n    /**\r\n     * Checks if the given node(s) are have outgoing connections to this node\r\n     *\r\n     * @param node Checks if `node(s)` have outgoing connections into this node\r\n     *\r\n     * @return Returns true, if every node(s) has an outgoing connection into this node\r\n     */\r\n    isProjectedBy(node) {\r\n        if (node === this) { // self connection\r\n            return this.selfConnection.weight !== 0; // is projected, if weight of self connection is unequal 0\r\n        }\r\n        else {\r\n            return Array.from(this.incoming).map(conn => conn.from).includes(node); // check every incoming connection for node\r\n        }\r\n    }\r\n    /**\r\n     * Checks if this node has an outgoing connection(s) into the given node(s)\r\n     *\r\n     * @param node Checks if this node has outgoing connection(s) into `node(s)`\r\n     *\r\n     * @returns Returns true, if this node has an outgoing connection into every node(s)\r\n     */\r\n    isProjectingTo(node) {\r\n        if (node === this) { // self connection\r\n            return this.selfConnection.weight !== 0; // is projected, if weight of self connection is unequal 0\r\n        }\r\n        else {\r\n            return Array.from(this.outgoing).map(conn => conn.to).includes(node); // check every outgoing connection for node\r\n        }\r\n    }\r\n    /**\r\n     * This node gates (influences) the given connection\r\n     *\r\n     * @param connection Connection to be gated (influenced) by a neuron\r\n     */\r\n    addGate(connection) {\r\n        this.gated.add(connection);\r\n        connection.gateNode = this;\r\n    }\r\n    /**\r\n     * Stops this node from gating (manipulating) the given connection(s)\r\n     *\r\n     * @param connection Connections to remove gate - _i.e. remove this node from_\r\n     */\r\n    removeGate(connection) {\r\n        this.gated.delete(connection);\r\n        connection.gateNode = null;\r\n        connection.gain = 1;\r\n    }\r\n    /**\r\n     * Connects this node to the given node(s)\r\n     *\r\n     * @param target Node(s) to project connection(s) to\r\n     * @param weight Initial connection(s) [weight](https://en.wikipedia.org/wiki/Synaptic_weight)\r\n     * @param twoSided If `true` connect nodes to each other\r\n     */\r\n    connect(target, weight = 1, twoSided = false) {\r\n        if (target === this) { // self connection\r\n            this.selfConnection.weight = weight;\r\n            return this.selfConnection;\r\n        }\r\n        else if (this.isProjectingTo(target)) {\r\n            throw new ReferenceError(\"Their is already a connection!\"); // already connected\r\n        }\r\n        else {\r\n            const connection = new Connection_1.Connection(this, target, weight); // create new connection\r\n            // add it to the arrays\r\n            this.outgoing.add(connection);\r\n            target.incoming.add(connection);\r\n            if (twoSided) {\r\n                target.connect(this); // connect in the other direction\r\n            }\r\n            return connection;\r\n        }\r\n    }\r\n    /**\r\n     * Disconnects this node from the given node(s)\r\n     *\r\n     * @param node Node(s) to remove connection(s) to\r\n     * @param twoSided=false If `true` disconnects nodes from each other (i.e. both sides)\r\n     */\r\n    disconnect(node, twoSided = false) {\r\n        if (node === this) { // self connection\r\n            this.selfConnection.weight = 0; // set weight to 0\r\n            return this.selfConnection;\r\n        }\r\n        const connections = Array.from(this.outgoing).filter(conn => conn.to === node);\r\n        if (connections.length === 0) {\r\n            throw new Error(\"No Connection found\");\r\n        }\r\n        const connection = connections[0];\r\n        // remove it from the arrays\r\n        this.outgoing.delete(connection);\r\n        connection.to.incoming.delete(connection);\r\n        if (connection.gateNode !== undefined && connection.gateNode != null) {\r\n            connection.gateNode.removeGate(connection); // if connection is gated -> remove gate\r\n        }\r\n        if (twoSided) {\r\n            node.disconnect(this); // disconnect the other direction\r\n        }\r\n        return connection;\r\n    }\r\n    /**\r\n     * Backpropagate the error (a.k.a. learn).\r\n     *\r\n     * After an activation, you can teach the node what should have been the correct output (a.k.a. train). This is done by backpropagating. [Momentum](https://www.willamette.edu/~gorr/classes/cs449/momrate.html) adds a fraction of the previous weight update to the current one. When the gradient keeps pointing in the same direction, this will increase the size of the steps taken towards the minimum.\r\n     *\r\n     * If you combine a high learning rate with a lot of momentum, you will rush past the minimum (of the error function) with huge steps. It is therefore often necessary to reduce the global learning rate  when using a lot of momentum (m close to 1).\r\n     *\r\n     * @param target The target value (i.e. \"the value the network SHOULD have given\")\r\n     * @param options More options for propagation\r\n     *\r\n     * @see [Regularization Neataptic](https://wagenaartje.github.io/neataptic/docs/methods/regularization/)\r\n     * @see [What is backpropagation | YouTube](https://www.youtube.com/watch?v=Ilg3gGewQ5U)\r\n     */\r\n    propagate(target, options = {}) {\r\n        var _a, _b, _c;\r\n        options.momentum = (_a = options.momentum) !== null && _a !== void 0 ? _a : 0;\r\n        options.rate = (_b = options.rate) !== null && _b !== void 0 ? _b : 0.3;\r\n        options.update = (_c = options.update) !== null && _c !== void 0 ? _c : true;\r\n        if (target !== undefined && Number.isFinite(target)) {\r\n            this.errorResponsibility = this.errorProjected = target - this.activation;\r\n        }\r\n        else {\r\n            this.errorProjected = 0;\r\n            this.outgoing.forEach(connection => {\r\n                this.errorProjected += connection.to.errorResponsibility * connection.weight * connection.gain;\r\n            });\r\n            this.errorProjected *= this.derivativeState;\r\n            this.errorGated = 0;\r\n            this.gated.forEach(connection => {\r\n                let influence;\r\n                if (connection.to.selfConnection.gateNode === this) { // self connection is gated with this node\r\n                    influence = connection.to.old + connection.weight * connection.from.activation;\r\n                }\r\n                else {\r\n                    influence = connection.weight * connection.from.activation;\r\n                }\r\n                this.errorGated += connection.to.errorResponsibility * influence;\r\n            });\r\n            this.errorGated *= this.derivativeState;\r\n            this.errorResponsibility = this.errorProjected + this.errorGated;\r\n        }\r\n        this.incoming.forEach(connection => {\r\n            var _a, _b;\r\n            // calculate gradient\r\n            let gradient = this.errorProjected * connection.eligibility;\r\n            connection.xTrace.forEach((value, key) => gradient += key.errorResponsibility * value);\r\n            connection.deltaWeightsTotal += ((_a = options.rate) !== null && _a !== void 0 ? _a : 0.3) * gradient * this.mask;\r\n            if (options.update) {\r\n                connection.deltaWeightsTotal += ((_b = options.momentum) !== null && _b !== void 0 ? _b : 0) * connection.deltaWeightsPrevious;\r\n                connection.weight += connection.deltaWeightsTotal;\r\n                connection.deltaWeightsPrevious = connection.deltaWeightsTotal;\r\n                connection.deltaWeightsTotal = 0;\r\n            }\r\n        });\r\n        this.deltaBiasTotal += options.rate * this.errorResponsibility;\r\n        if (options.update) {\r\n            this.deltaBiasTotal += options.momentum * this.deltaBiasPrevious;\r\n            this.bias += this.deltaBiasTotal;\r\n            this.deltaBiasPrevious = this.deltaBiasTotal;\r\n            this.deltaBiasTotal = 0;\r\n        }\r\n    }\r\n    /**\r\n     * Actives the node.\r\n     *\r\n     * When a neuron activates, it computes its state from all its input connections and 'squashes' it using its activation function, and returns the output (activation).\r\n     *\r\n     * You can also provide the activation (a float between 0 and 1) as a parameter, which is useful for neurons in the input layer.\r\n     *\r\n     * @param [input] Environment signal (i.e. optional numerical value passed to the network as input)  - _should only be passed in input neurons_\r\n     * @param [trace] Controls whether traces are created when activation happens (a trace is meta information left behind for different uses, e.g. backpropagation).\r\n     *\r\n     * @returns A neuron's ['Squashed'](https://medium.com/the-theory-of-everything/understanding-activation-functions-in-neural-networks-9491262884e0) output value\r\n     */\r\n    activate(input, trace = true) {\r\n        if (input !== undefined) {\r\n            return this.activation = input;\r\n        }\r\n        else if (this.isInputNode()) {\r\n            throw new ReferenceError(\"There is no input given to an input node!\");\r\n        }\r\n        if (trace) {\r\n            this.old = this.state;\r\n            this.state = this.selfConnection.gain * this.selfConnection.weight * this.state + this.bias;\r\n            this.incoming.forEach(conn => {\r\n                this.state += conn.from.activation * conn.weight * conn.gain;\r\n            });\r\n            this.activation = this.squash(this.state, false) * this.mask;\r\n            this.derivativeState = this.squash(this.state, true);\r\n            // store traces\r\n            const nodes = [];\r\n            const influences = [];\r\n            // Adjust 'gain' (to gated connections) & Build traces\r\n            this.gated.forEach(connection => {\r\n                connection.gain = this.activation;\r\n                // Build traces\r\n                const index = nodes.indexOf(connection.to);\r\n                if (index > -1) { // Node & influence exist\r\n                    influences[index] += connection.weight * connection.from.activation;\r\n                }\r\n                else { // Add node & corresponding influence\r\n                    nodes.push(connection.to);\r\n                    if (connection.to.selfConnection.gateNode === this) {\r\n                        influences.push(connection.weight * connection.from.activation + connection.to.old);\r\n                    }\r\n                    else {\r\n                        influences.push(connection.weight * connection.from.activation);\r\n                    }\r\n                }\r\n            });\r\n            // Forwarding 'xTrace' (to incoming connections)\r\n            this.incoming.forEach(connection => {\r\n                var _a;\r\n                connection.eligibility = this.selfConnection.gain * this.selfConnection.weight * connection.eligibility + connection.from.activation * connection.gain;\r\n                for (let i = 0; i < nodes.length; i++) {\r\n                    const node = nodes[i];\r\n                    const influence = influences[i];\r\n                    if (connection.xTrace.has(node)) {\r\n                        connection.xTrace.set(node, node.selfConnection.gain * node.selfConnection.weight * ((_a = connection.xTrace.get(node)) !== null && _a !== void 0 ? _a : 0) + this.derivativeState * connection.eligibility * influence);\r\n                    }\r\n                    else {\r\n                        connection.xTrace.set(node, this.derivativeState * connection.eligibility * influence);\r\n                    }\r\n                }\r\n            });\r\n            return this.activation;\r\n        }\r\n        else {\r\n            if (this.isInputNode())\r\n                return this.activation = 0;\r\n            this.state = this.selfConnection.gain * this.selfConnection.weight * this.state + this.bias;\r\n            this.incoming.forEach(connection => this.state += connection.from.activation * connection.weight * connection.gain);\r\n            this.activation = this.squash(this.state, false);\r\n            // Adjust gain\r\n            this.gated.forEach(connection => connection.gain = this.activation);\r\n            return this.activation;\r\n        }\r\n    }\r\n    /**\r\n     * Converts the node to a json object that can later be converted back\r\n     *\r\n     * @returns A node representing json object\r\n     */\r\n    toJSON() {\r\n        return {\r\n            bias: this.bias,\r\n            type: this.type,\r\n            squash: this.squash,\r\n            mask: this.mask,\r\n            index: this.index\r\n        };\r\n    }\r\n    /**\r\n     * Is this a input Node?\r\n     */\r\n    isInputNode() {\r\n        return this.type === NodeType_1.NodeType.INPUT;\r\n    }\r\n    /**\r\n     * Is this a hidden Node?\r\n     */\r\n    isHiddenNode() {\r\n        return this.type === NodeType_1.NodeType.HIDDEN;\r\n    }\r\n    /**\r\n     * Is this a output Node?\r\n     */\r\n    isOutputNode() {\r\n        return this.type === NodeType_1.NodeType.OUTPUT;\r\n    }\r\n    /**\r\n     * Set bias.\r\n     *\r\n     * @param bias the new bias value\r\n     */\r\n    setBias(bias) {\r\n        this.bias = bias;\r\n        return this;\r\n    }\r\n    /**\r\n     * Set activation type\r\n     *\r\n     * @param activation the new activation type\r\n     */\r\n    setActivationType(activation) {\r\n        this.squash = activation;\r\n        return this;\r\n    }\r\n}\r\nexports.Node = Node;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GatingType = void 0;\r\n/**\r\n * The type of gating.\r\n */\r\nvar GatingType;\r\n(function (GatingType) {\r\n    /**\r\n     * Gate incoming connections.\r\n     */\r\n    GatingType[GatingType[\"INPUT\"] = 0] = \"INPUT\";\r\n    /**\r\n     * Gate self connections.\r\n     */\r\n    GatingType[GatingType[\"SELF\"] = 1] = \"SELF\";\r\n    /**\r\n     * Gate outgoing connections.\r\n     */\r\n    GatingType[GatingType[\"OUTPUT\"] = 2] = \"OUTPUT\";\r\n})(GatingType = exports.GatingType || (exports.GatingType = {}));\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Layer = void 0;\r\nconst ConnectionType_1 = require(\"../../enums/ConnectionType\");\r\nconst GatingType_1 = require(\"../../enums/GatingType\");\r\n/**\r\n * Parent class for layers.\r\n */\r\nclass Layer {\r\n    constructor(outputSize) {\r\n        this.outputSize = outputSize;\r\n        this.nodes = [];\r\n        this.inputNodes = new Set();\r\n        this.outputNodes = new Set();\r\n        this.connections = [];\r\n        this.gates = [];\r\n    }\r\n    /**\r\n     * Connect two Layers or sets of Nodes.\r\n     *\r\n     * @param from origin Nodes / Layer\r\n     * @param to destination Nodes / Layer\r\n     * @param connectionType The type of connection\r\n     * @param weight the initial weights for all new connections\r\n     *\r\n     * @returns all created connections\r\n     */\r\n    static connect(from, to, connectionType = ConnectionType_1.ConnectionType.ALL_TO_ALL, weight = 1) {\r\n        if (connectionType === ConnectionType_1.ConnectionType.NO_CONNECTION) {\r\n            throw new ReferenceError(\"Cannot connect with 'NO_CONNECTION' connection type\");\r\n        }\r\n        const fromNodes = Array.from(from instanceof Layer ? from.outputNodes : from);\r\n        const toNodes = Array.from(to instanceof Layer ? to.inputNodes : to);\r\n        if (toNodes.length === 0) {\r\n            throw new ReferenceError(\"Target from has no input nodes!\");\r\n        }\r\n        if (fromNodes.length === 0) {\r\n            throw new ReferenceError(\"This from has no output nodes!\");\r\n        }\r\n        const connections = [];\r\n        if (connectionType === ConnectionType_1.ConnectionType.ALL_TO_ALL) {\r\n            fromNodes.forEach(fromNode => {\r\n                toNodes.forEach(toNode => {\r\n                    connections.push(fromNode.connect(toNode, weight)); // connect every \"from node\" to every \"to node\"\r\n                });\r\n            });\r\n        }\r\n        else if (connectionType === ConnectionType_1.ConnectionType.ONE_TO_ONE) {\r\n            if (fromNodes.length !== toNodes.length) {\r\n                throw new RangeError(\"Can't connect one to one! Number of output nodes from are unequal number of incoming nodes from next layer!\");\r\n            }\r\n            for (let i = 0; i < fromNodes.length; i++) {\r\n                connections.push(fromNodes[i].connect(toNodes[i], weight)); // connect every nodes with same indices\r\n            }\r\n        }\r\n        else if (connectionType === ConnectionType_1.ConnectionType.POOLING) {\r\n            // connect the same amount of input nodes to every output node\r\n            // every input node has only one connection available\r\n            const ratio = toNodes.length / fromNodes.length;\r\n            connections.push(...fromNodes.map((node, index) => node.connect(toNodes[Math.floor(index * ratio)], weight)));\r\n        }\r\n        return connections;\r\n    }\r\n    /**\r\n     * Gate nodes and connections.\r\n     *\r\n     * @param nodes the nodes which function as gateNodes\r\n     * @param connections the connections which will be gated\r\n     * @param gateType The type of gating\r\n     *\r\n     * @returns all gated connections\r\n     */\r\n    static gate(nodes, connections, gateType) {\r\n        const gatedConnections = [];\r\n        switch (gateType) {\r\n            case GatingType_1.GatingType.INPUT: { // gate incoming connections\r\n                const toNodes = Array.from(new Set(connections.map(conn => conn.to)));\r\n                for (let i = 0; i < toNodes.length; i++) {\r\n                    const node = toNodes[i];\r\n                    const gateNode = nodes[i % nodes.length];\r\n                    node.incoming\r\n                        .forEach(conn => {\r\n                        if (connections.includes(conn)) {\r\n                            gateNode.addGate(conn);\r\n                            gatedConnections.push(conn);\r\n                        }\r\n                    });\r\n                }\r\n                break;\r\n            }\r\n            case GatingType_1.GatingType.SELF: { // gate self connections\r\n                const fromNodes = Array.from(new Set(connections.map(conn => conn.from)));\r\n                for (let i = 0; i < fromNodes.length; i++) {\r\n                    if (connections.includes(fromNodes[i].selfConnection)) {\r\n                        nodes[i % nodes.length].addGate(fromNodes[i].selfConnection);\r\n                        gatedConnections.push(fromNodes[i].selfConnection);\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case GatingType_1.GatingType.OUTPUT: { // gate outgoing connections\r\n                const fromNodes = Array.from(new Set(connections.map(conn => conn.from)));\r\n                for (let i = 0; i < fromNodes.length; i++) {\r\n                    const node = fromNodes[i];\r\n                    const gateNode = nodes[i % nodes.length];\r\n                    node.outgoing\r\n                        .forEach(conn => {\r\n                        if (connections.includes(conn)) {\r\n                            gateNode.addGate(conn);\r\n                            gatedConnections.push(conn);\r\n                        }\r\n                    });\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        return gatedConnections;\r\n    }\r\n}\r\nexports.Layer = Layer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ConstantNode = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst NodeType_1 = require(\"../../enums/NodeType\");\r\nconst Node_1 = require(\"../Node\");\r\n/**\r\n * Constant node\r\n */\r\nclass ConstantNode extends Node_1.Node {\r\n    constructor() {\r\n        super(NodeType_1.NodeType.HIDDEN);\r\n        this.bias = 1;\r\n    }\r\n    /**\r\n     * Create a constant node from json object.\r\n     *\r\n     * @param json the json object representing the node\r\n     *\r\n     * @returns the created node\r\n     */\r\n    fromJSON(json) {\r\n        var _a, _b;\r\n        this.index = (_a = json.index) !== null && _a !== void 0 ? _a : -1;\r\n        this.squash = (_b = json.squash) !== null && _b !== void 0 ? _b : src_1.Identitiy;\r\n        return this;\r\n    }\r\n    /**\r\n     * Convert this node into a json object.\r\n     *\r\n     * @returns the json object representing this node\r\n     */\r\n    toJSON() {\r\n        return { index: this.index, squash: this.squash };\r\n    }\r\n    /**\r\n     * Bias mutations aren't allowed for a constant node.\r\n     */\r\n    mutateBias() {\r\n        throw new ReferenceError(\"Cannot mutate a pool node!\");\r\n    }\r\n    /**\r\n     * Activation mutations aren't allowed for a constant node.\r\n     */\r\n    mutateActivation() {\r\n        throw new ReferenceError(\"Cannot mutate a pool node!\");\r\n    }\r\n    /**\r\n     * Constant nodes can't gate a connection.\r\n     */\r\n    addGate() {\r\n        throw new ReferenceError(\"A pool node can't gate a connection!\");\r\n    }\r\n    /**\r\n     * Constant nodes can't gate a connection.\r\n     */\r\n    removeGate() {\r\n        throw new ReferenceError(\"A pool node can't gate a connection!\");\r\n    }\r\n    /**\r\n     * Can't set the bias of a constant node.\r\n     */\r\n    setBias() {\r\n        throw new ReferenceError(\"Cannot set the bias of a pool node!\");\r\n    }\r\n}\r\nexports.ConstantNode = ConstantNode;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NoiseNode = void 0;\r\nconst NodeType_1 = require(\"../../enums/NodeType\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nconst ConstantNode_1 = require(\"./ConstantNode\");\r\n/**\r\n * Noise node\r\n */\r\nclass NoiseNode extends ConstantNode_1.ConstantNode {\r\n    constructor(options = {}) {\r\n        var _a;\r\n        super();\r\n        this.noiseType = (_a = options.noiseType) !== null && _a !== void 0 ? _a : NodeType_1.NoiseNodeType.GAUSSIAN_NOISE;\r\n        this.options = options;\r\n    }\r\n    /**\r\n     * Actives the node.\r\n     *\r\n     * When a neuron activates, it computes its state from all its input connections and 'squashes' it using its activation function, and returns the output (activation).\r\n     *\r\n     * You can also provide the activation (a float between 0 and 1) as a parameter, which is useful for neurons in the input layer.\r\n     *\r\n     * @returns A neuron's output value\r\n     */\r\n    activate() {\r\n        var _a, _b, _c, _d;\r\n        this.old = this.state;\r\n        const incomingStates = Array.from(this.incoming).map(conn => conn.from.activation * conn.weight * conn.gain);\r\n        switch (this.noiseType) {\r\n            case NodeType_1.NoiseNodeType.GAUSSIAN_NOISE:\r\n                this.state = Utils_1.avg(incomingStates) + Utils_1.generateGaussian((_b = (_a = this.options.gaussian) === null || _a === void 0 ? void 0 : _a.mean) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this.options.gaussian) === null || _c === void 0 ? void 0 : _c.deviation) !== null && _d !== void 0 ? _d : 2);\r\n                break;\r\n            default:\r\n                throw new ReferenceError(\"Cannot activate this noise type!\");\r\n        }\r\n        this.activation = this.squash(this.state, false) * this.mask;\r\n        this.derivativeState = this.squash(this.state, true);\r\n        return this.activation;\r\n    }\r\n    /**\r\n     * Backpropagate the error (a.k.a. learn).\r\n     *\r\n     * After an activation, you can teach the node what should have been the correct output (a.k.a. train). This is done by backpropagating. [Momentum](https://www.willamette.edu/~gorr/classes/cs449/momrate.html) adds a fraction of the previous weight update to the current one. When the gradient keeps pointing in the same direction, this will increase the size of the steps taken towards the minimum.\r\n     *\r\n     * If you combine a high learning rate with a lot of momentum, you will rush past the minimum (of the error function) with huge steps. It is therefore often necessary to reduce the global learning rate  when using a lot of momentum (m close to 1).\r\n     *\r\n     * @param target The target value (i.e. \"the value the network SHOULD have given\")\r\n     * @param options More options for propagation\r\n     */\r\n    propagate(target, options = {}) {\r\n        var _a, _b, _c;\r\n        options.momentum = (_a = options.momentum) !== null && _a !== void 0 ? _a : 0;\r\n        options.rate = (_b = options.rate) !== null && _b !== void 0 ? _b : 0.3;\r\n        options.update = (_c = options.update) !== null && _c !== void 0 ? _c : true;\r\n        const connectionsStates = Array.from(this.outgoing).map(conn => conn.to.errorResponsibility * conn.weight * conn.gain);\r\n        this.errorResponsibility = this.errorProjected = Utils_1.sum(connectionsStates) * this.derivativeState;\r\n        this.incoming.forEach(connection => {\r\n            var _a, _b;\r\n            // calculate gradient\r\n            let gradient = this.errorProjected * connection.eligibility;\r\n            connection.xTrace.forEach((value, key) => {\r\n                gradient += key.errorResponsibility * value;\r\n            });\r\n            connection.deltaWeightsTotal += ((_a = options.rate) !== null && _a !== void 0 ? _a : 0.3) * gradient * this.mask;\r\n            if (options.update) {\r\n                connection.deltaWeightsTotal += ((_b = options.momentum) !== null && _b !== void 0 ? _b : 0) * connection.deltaWeightsPrevious;\r\n                connection.weight += connection.deltaWeightsTotal;\r\n                connection.deltaWeightsPrevious = connection.deltaWeightsTotal;\r\n                connection.deltaWeightsTotal = 0;\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.NoiseNode = NoiseNode;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NoiseLayer = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst ConnectionType_1 = require(\"../../../enums/ConnectionType\");\r\nconst NodeType_1 = require(\"../../../enums/NodeType\");\r\nconst NoiseNode_1 = require(\"../../Nodes/NoiseNode\");\r\nconst Layer_1 = require(\"../Layer\");\r\n/**\r\n * Noise layer\r\n */\r\nclass NoiseLayer extends Layer_1.Layer {\r\n    constructor(outputSize, options = {}) {\r\n        var _a;\r\n        super(outputSize);\r\n        const activation = (_a = options.activation) !== null && _a !== void 0 ? _a : src_1.Identitiy;\r\n        for (let i = 0; i < outputSize; i++) {\r\n            this.inputNodes.add(new NoiseNode_1.NoiseNode({\r\n                noiseType: NodeType_1.NoiseNodeType.GAUSSIAN_NOISE,\r\n                gaussian: options\r\n            }).setActivationType(activation));\r\n        }\r\n        this.outputNodes = this.inputNodes;\r\n        this.nodes.push(...Array.from(this.inputNodes));\r\n    }\r\n    /**\r\n     * Gets the default connection type for a incoming connection to this layer.\r\n     *\r\n     * @returns the default incoming connection\r\n     */\r\n    getDefaultIncomingConnectionType() {\r\n        return ConnectionType_1.ConnectionType.ONE_TO_ONE;\r\n    }\r\n    /**\r\n     * Checks if a given connection type is allowed on this layer.\r\n     *\r\n     * @param type the type to check\r\n     *\r\n     * @return Is this connection type allowed?\r\n     */\r\n    connectionTypeisAllowed(type) {\r\n        return type === ConnectionType_1.ConnectionType.ONE_TO_ONE;\r\n    }\r\n}\r\nexports.NoiseLayer = NoiseLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.InputLayer = void 0;\r\nconst ConnectionType_1 = require(\"../../../enums/ConnectionType\");\r\nconst NodeType_1 = require(\"../../../enums/NodeType\");\r\nconst Node_1 = require(\"../../Node\");\r\nconst Layer_1 = require(\"../Layer\");\r\nconst NoiseLayer_1 = require(\"../NoiseLayers/NoiseLayer\");\r\n/**\r\n * Input layer\r\n */\r\nclass InputLayer extends Layer_1.Layer {\r\n    constructor(outputSize, options = {}) {\r\n        super(outputSize);\r\n        for (let i = 0; i < outputSize; i++) {\r\n            const node = new Node_1.Node(NodeType_1.NodeType.INPUT);\r\n            this.nodes.push(node);\r\n        }\r\n        if (options.noise) {\r\n            const noiseLayer = new NoiseLayer_1.NoiseLayer(options.noise);\r\n            noiseLayer.outputNodes.forEach(node => this.outputNodes.add(node));\r\n            this.connections.push(...Layer_1.Layer.connect(this.nodes, noiseLayer, noiseLayer.getDefaultIncomingConnectionType()));\r\n        }\r\n        else {\r\n            this.nodes.forEach(node => this.outputNodes.add(node));\r\n        }\r\n    }\r\n    /**\r\n     * Gets the default connection type for a incoming connection to this layer.\r\n     *\r\n     * @returns the default incoming connection\r\n     */\r\n    getDefaultIncomingConnectionType() {\r\n        return ConnectionType_1.ConnectionType.NO_CONNECTION;\r\n    }\r\n    /**\r\n     * Checks if a given connection type is allowed on this layer.\r\n     *\r\n     * @param type the type to check\r\n     *\r\n     * @return Is this connection type allowed?\r\n     */\r\n    connectionTypeisAllowed(type) {\r\n        return type === ConnectionType_1.ConnectionType.NO_CONNECTION;\r\n    }\r\n}\r\nexports.InputLayer = InputLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.OutputLayer = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst ConnectionType_1 = require(\"../../../enums/ConnectionType\");\r\nconst NodeType_1 = require(\"../../../enums/NodeType\");\r\nconst Node_1 = require(\"../../Node\");\r\nconst Layer_1 = require(\"../Layer\");\r\n/**\r\n * Output layer\r\n */\r\nclass OutputLayer extends Layer_1.Layer {\r\n    constructor(outputSize, options = {}) {\r\n        var _a;\r\n        super(outputSize);\r\n        const activation = (_a = options.activation) !== null && _a !== void 0 ? _a : src_1.Identitiy;\r\n        for (let i = 0; i < outputSize; i++) {\r\n            this.inputNodes.add(new Node_1.Node(NodeType_1.NodeType.OUTPUT).setActivationType(activation));\r\n        }\r\n        this.nodes.push(...Array.from(this.inputNodes));\r\n    }\r\n    /**\r\n     * A outgoing connection is not allowed for an output layer!\r\n     */\r\n    connect() {\r\n        throw new ReferenceError(\"Could not connect an OutputLayer!\");\r\n    }\r\n    /**\r\n     * Checks if a given connection type is allowed on this layer.\r\n     *\r\n     * @param type the type to check\r\n     *\r\n     * @return Is this connection type allowed?\r\n     */\r\n    connectionTypeisAllowed(type) {\r\n        return true;\r\n    }\r\n    /**\r\n     * Gets the default connection type for a incoming connection to this layer.\r\n     *\r\n     * @returns the default incoming connection\r\n     */\r\n    getDefaultIncomingConnectionType() {\r\n        return ConnectionType_1.ConnectionType.ALL_TO_ALL;\r\n    }\r\n}\r\nexports.OutputLayer = OutputLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ALL_LOSSES = exports.HINGELoss = exports.MSLELoss = exports.WAPELoss = exports.MAPELoss = exports.MAELoss = exports.BinaryLoss = exports.MBELoss = exports.MSELoss = void 0;\r\nconst Utils_1 = require(\"../utils/Utils\");\r\nexports.MSELoss = function (targets, outputs) {\r\n    let error = 0;\r\n    outputs.forEach(((value, index) => {\r\n        error += Math.pow((targets[index] - value), 2);\r\n    }));\r\n    return error / outputs.length;\r\n};\r\nexports.MBELoss = function (targets, outputs) {\r\n    let error = 0;\r\n    outputs.forEach(((value, index) => {\r\n        error += (targets[index] - value);\r\n    }));\r\n    return error / outputs.length;\r\n};\r\nexports.BinaryLoss = function (targets, outputs) {\r\n    let error = 0;\r\n    outputs.forEach(((value, index) => {\r\n        error += Math.round(targets[index] * 2) !== Math.round(value * 2) ? 1 : 0;\r\n    }));\r\n    return error / outputs.length;\r\n};\r\nexports.MAELoss = function (targets, outputs) {\r\n    let error = 0;\r\n    outputs.forEach(((value, index) => {\r\n        error += Math.abs(targets[index] - value);\r\n    }));\r\n    return error / outputs.length;\r\n};\r\nexports.MAPELoss = function (targets, outputs) {\r\n    let error = 0;\r\n    outputs.forEach(((value, index) => {\r\n        error += Math.abs((value - targets[index]) / Math.max(targets[index], 1e-15));\r\n    }));\r\n    return error / outputs.length;\r\n};\r\nexports.WAPELoss = function (targets, outputs) {\r\n    let error = 0;\r\n    outputs.forEach(((value, index) => {\r\n        error += Math.abs(targets[index] - value);\r\n    }));\r\n    return error / Utils_1.sum(targets);\r\n};\r\nexports.MSLELoss = function (targets, outputs) {\r\n    let error = 0;\r\n    outputs.forEach(((value, index) => {\r\n        error += Math.log(Math.max(targets[index], 1e-15)) - Math.log(Math.max(value, 1e-15));\r\n    }));\r\n    return error / outputs.length;\r\n};\r\nexports.HINGELoss = function (targets, outputs) {\r\n    let error = 0;\r\n    outputs.forEach((value, index) => {\r\n        error += Math.max(0, 1 - value * targets[index]);\r\n    });\r\n    return error / outputs.length;\r\n};\r\nexports.ALL_LOSSES = {\r\n    MSELoss: exports.MSELoss,\r\n    MBELoss: exports.MBELoss,\r\n    BinaryLoss: exports.BinaryLoss,\r\n    MAELoss: exports.MAELoss,\r\n    MAPELoss: exports.MAPELoss,\r\n    WAPELoss: exports.WAPELoss,\r\n    MSLELoss: exports.MSLELoss,\r\n    HINGELoss: exports.HINGELoss\r\n};\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TournamentSelection = exports.PowerSelection = exports.FitnessProportionateSelection = exports.Selection = void 0;\r\nconst TimSort = __importStar(require(\"timsort\"));\r\nconst Utils_1 = require(\"../utils/Utils\");\r\n/**\r\n * Genetic Algorithm Selection Methods (Genetic Operator)\r\n *\r\n * @see [Genetic Algorithm - Selection]{@link https://en.wikipedia.org/wiki/Selection_(genetic_algorithm)}\r\n */\r\nclass Selection {\r\n}\r\nexports.Selection = Selection;\r\n/**\r\n * Fitness proportionate selection\r\n *\r\n * [Fitness Proportionate / Roulette Wheel Selection on Wikipedia](https://en.wikipedia.org/wiki/Fitness_proportionate_selection)\r\n */\r\nclass FitnessProportionateSelection extends Selection {\r\n    /**\r\n     * Selects a genome from the population according to the Selection method.\r\n     *\r\n     * @param population the pool of networks\r\n     * @returns the selected genome\r\n     */\r\n    select(population) {\r\n        var _a, _b, _c;\r\n        let totalFitness = 0;\r\n        let minimalFitness = 0;\r\n        for (const genome of population) {\r\n            minimalFitness = Math.min((_a = genome.score) !== null && _a !== void 0 ? _a : minimalFitness, minimalFitness);\r\n            totalFitness += (_b = genome.score) !== null && _b !== void 0 ? _b : 0;\r\n        }\r\n        minimalFitness = Math.abs(minimalFitness);\r\n        totalFitness += minimalFitness * population.length;\r\n        const random = Utils_1.randDouble(0, totalFitness);\r\n        let value = 0;\r\n        for (const genome of population) {\r\n            value += ((_c = genome.score) !== null && _c !== void 0 ? _c : 0) + minimalFitness;\r\n            if (random < value) {\r\n                return genome;\r\n            }\r\n        }\r\n        return Utils_1.pickRandom(population);\r\n    }\r\n}\r\nexports.FitnessProportionateSelection = FitnessProportionateSelection;\r\n/**\r\n * Power selection\r\n *\r\n * A random decimal value between 0 and 1 will be generated (e.g. 0.5) then this value will get an exponential value (power, default is 4). So 0.5**4 = 0.0625. This is converted into an index for the array of the current population, sorted from fittest to worst.\r\n */\r\nclass PowerSelection extends Selection {\r\n    /**\r\n     * Constructs a power selection.\r\n     * @param power Probability of picking better networks.\r\n     */\r\n    constructor(power = 4) {\r\n        super();\r\n        this.power = power;\r\n    }\r\n    /**\r\n     * Selects a genome from the population according to the Selection method.\r\n     *\r\n     * @param population the pool of networks\r\n     * @returns the selected genome\r\n     */\r\n    select(population) {\r\n        return population[Math.floor(Math.pow(Math.random(), this.power) * population.length)];\r\n    }\r\n}\r\nexports.PowerSelection = PowerSelection;\r\n/**\r\n * Tournament selection\r\n *\r\n * [Tournament Selection on Wikipedia](https://en.wikipedia.org/wiki/Tournament_selection)\r\n */\r\nclass TournamentSelection extends Selection {\r\n    /**\r\n     * Constructs a tournament selection.\r\n     * @param size the size of a tournament\r\n     * @param probability Selects the best individual (when probability = 1).\r\n     */\r\n    constructor(size = 5, probability = 0.5) {\r\n        super();\r\n        this.size = size;\r\n        this.probability = probability;\r\n    }\r\n    /**\r\n     * Selects a genome from the population according to the Selection method.\r\n     *\r\n     * @param population the pool of networks\r\n     * @returns the selected genome\r\n     */\r\n    select(population) {\r\n        if (this.size > population.length) {\r\n            throw new Error(`Your tournament size should be lower than the population size, please change methods.selection.TOURNAMENT.size`);\r\n        }\r\n        // Create a tournament\r\n        const individuals = [];\r\n        for (let i = 0; i < this.size; i++) {\r\n            individuals.push(Utils_1.pickRandom(population));\r\n        }\r\n        // Sort the tournament individuals by score\r\n        TimSort.sort(individuals, (a, b) => {\r\n            return b.score === undefined || a.score === undefined ? 0 : b.score - a.score;\r\n        });\r\n        // Select an individual\r\n        for (let i = 0; i < this.size; i++) {\r\n            if (Math.random() < this.probability || i === this.size - 1) {\r\n                return individuals[i];\r\n            }\r\n        }\r\n        return Utils_1.pickRandom(population);\r\n    }\r\n}\r\nexports.TournamentSelection = TournamentSelection;\r\n","\"use strict\";\r\nvar __importDefault = (this && this.__importDefault) || function (mod) {\r\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.EvolveOptions = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst os_1 = __importDefault(require(\"os\"));\r\nconst Network_1 = require(\"../architecture/Network\");\r\nconst Loss_1 = require(\"../methods/Loss\");\r\nconst Mutation_1 = require(\"../methods/Mutation\");\r\nconst Selection_1 = require(\"../methods/Selection\");\r\n/**\r\n * Options used to evolve network\r\n */\r\nclass EvolveOptions {\r\n    constructor() {\r\n        /**\r\n         * How big could the distance be between a network and the represent of a species?\r\n         */\r\n        this._speciesDistanceThreshold = 4;\r\n        this._c1 = 1;\r\n        this._c2 = 1;\r\n        this._c3 = 1;\r\n        this._survivors = 0.8;\r\n        this._input = 1;\r\n        this._output = 1;\r\n        this._generation = 0;\r\n        this._elitism = 1;\r\n        this._equal = true;\r\n        this._clear = false;\r\n        this._populationSize = 50;\r\n        this._mutationRate = 0.6;\r\n        this._mutationAmount = 5;\r\n        this._selection = new Selection_1.FitnessProportionateSelection();\r\n        this._loss = Loss_1.MSELoss;\r\n        this._mutations = Mutation_1.FEEDFORWARD_MUTATIONS;\r\n        this._activations = Object.values(src_1.ALL_ACTIVATIONS);\r\n        this._template = new Network_1.Network(this._input, this._output);\r\n        this._maxNodes = Infinity;\r\n        this._maxConnections = Infinity;\r\n        this._maxGates = Infinity;\r\n        this._threads = os_1.default.cpus().length;\r\n        this._log = -1;\r\n        this._iterations = 1000;\r\n        this._error = 0.05;\r\n        this._maxStagnation = 3;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get maxStagnation() {\r\n        return this._maxStagnation;\r\n    }\r\n    /**\r\n     * Setter\r\n     * @param value\r\n     */\r\n    set maxStagnation(value) {\r\n        this._maxStagnation = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get speciesDistanceThreshold() {\r\n        return this._speciesDistanceThreshold;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set speciesDistanceThreshold(value) {\r\n        this._speciesDistanceThreshold = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get c1() {\r\n        return this._c1;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set c1(value) {\r\n        this._c1 = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get c2() {\r\n        return this._c2;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set c2(value) {\r\n        this._c2 = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get c3() {\r\n        return this._c3;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set c3(value) {\r\n        this._c3 = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get survivors() {\r\n        return this._survivors;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set survivors(value) {\r\n        this._survivors = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get threads() {\r\n        return this._threads;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set threads(value) {\r\n        this._threads = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get input() {\r\n        return this._input;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set input(value) {\r\n        this._input = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get output() {\r\n        return this._output;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set output(value) {\r\n        this._output = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get dataset() {\r\n        return this._dataset;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set dataset(value) {\r\n        this._dataset = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get generation() {\r\n        return this._generation;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set generation(value) {\r\n        this._generation = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get training() {\r\n        return this._training;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set training(value) {\r\n        this._training = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get template() {\r\n        return this._template;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set template(value) {\r\n        this._template = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get mutations() {\r\n        return this._mutations;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set mutations(value) {\r\n        this._mutations = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get activations() {\r\n        return this._activations;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set activations(value) {\r\n        this._activations = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get selection() {\r\n        return this._selection;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set selection(value) {\r\n        this._selection = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get mutationRate() {\r\n        return this._mutationRate;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set mutationRate(value) {\r\n        this._mutationRate = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get mutationAmount() {\r\n        return this._mutationAmount;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set mutationAmount(value) {\r\n        this._mutationAmount = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get elitism() {\r\n        return this._elitism;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set elitism(value) {\r\n        this._elitism = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get populationSize() {\r\n        return this._populationSize;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set populationSize(value) {\r\n        this._populationSize = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get fitnessFunction() {\r\n        return this._fitnessFunction;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set fitnessFunction(value) {\r\n        this._fitnessFunction = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get loss() {\r\n        return this._loss;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set loss(value) {\r\n        this._loss = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get maxNodes() {\r\n        return this._maxNodes;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set maxNodes(value) {\r\n        this._maxNodes = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get maxConnections() {\r\n        return this._maxConnections;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set maxConnections(value) {\r\n        this._maxConnections = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get maxGates() {\r\n        return this._maxGates;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set maxGates(value) {\r\n        this._maxGates = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get equal() {\r\n        return this._equal;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set equal(value) {\r\n        this._equal = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get log() {\r\n        return this._log;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set log(value) {\r\n        this._log = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get schedule() {\r\n        return this._schedule;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set schedule(value) {\r\n        this._schedule = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get clear() {\r\n        return this._clear;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set clear(value) {\r\n        this._clear = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get iterations() {\r\n        return this._iterations;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set iterations(value) {\r\n        this._iterations = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get error() {\r\n        return this._error;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set error(value) {\r\n        this._error = value;\r\n    }\r\n}\r\nexports.EvolveOptions = EvolveOptions;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Species = void 0;\r\nconst TimSort = __importStar(require(\"timsort\"));\r\nconst Utils_1 = require(\"../utils/Utils\");\r\nconst Network_1 = require(\"./Network\");\r\n/**\r\n * A class holding a species\r\n */\r\nclass Species {\r\n    constructor(representative) {\r\n        this.representative = representative;\r\n        this.representative.species = this;\r\n        this.members = new Set();\r\n        this.members.add(representative);\r\n        this._score = 0;\r\n        this.lastScore = 0;\r\n        this._stagnation = 0;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get score() {\r\n        return this._score;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get stagnation() {\r\n        return this._stagnation;\r\n    }\r\n    /**\r\n     * Puts a network to the species, after checking the distance\r\n     * @param network\r\n     * @param c1\r\n     * @param c2\r\n     * @param c3\r\n     * @param distanceThreshold\r\n     */\r\n    put(network, c1, c2, c3, distanceThreshold) {\r\n        if (network.distance(this.representative, c1, c2, c3) < distanceThreshold) {\r\n            this.forcePut(network);\r\n            return true;\r\n        }\r\n        else {\r\n            return false;\r\n        }\r\n    }\r\n    /**\r\n     * Puts a network to the species without checking the distance\r\n     * @param network\r\n     */\r\n    forcePut(network) {\r\n        if (network === undefined) {\r\n            return;\r\n        }\r\n        this.members.add(network);\r\n        network.species = this;\r\n    }\r\n    /**\r\n     * Calculate the score of this species\r\n     */\r\n    evaluateScore() {\r\n        let sum = 0;\r\n        this.members.forEach(network => { var _a; return sum += (_a = network.score) !== null && _a !== void 0 ? _a : 0; });\r\n        const score = sum / this.members.size;\r\n        if (this.lastScore < score) {\r\n            this._stagnation++;\r\n        }\r\n        else {\r\n            this._stagnation = 0;\r\n        }\r\n        this._score = score;\r\n    }\r\n    /**\r\n     * Reset this object\r\n     */\r\n    reset() {\r\n        this.representative = Utils_1.pickRandom(this.members);\r\n        this.members.forEach(genome => genome.species = null);\r\n        this.members.clear();\r\n        this.members.add(this.representative);\r\n        this.representative.species = this;\r\n        this.lastScore = this.score;\r\n        this._score = 0;\r\n    }\r\n    /**\r\n     * Kill a specific percentage of networks\r\n     * @param percentage\r\n     */\r\n    kill(percentage) {\r\n        const arr = Array.from(this.members);\r\n        TimSort.sort(arr, (a, b) => {\r\n            return a.score === undefined || b.score === undefined ? 0 : a.score - b.score;\r\n        });\r\n        const amount = Math.floor(percentage * this.members.size);\r\n        for (let i = 0; i < amount; i++) {\r\n            this.members.delete(arr[i]);\r\n            arr[i].species = null;\r\n        }\r\n    }\r\n    /**\r\n     * Create offspring\r\n     */\r\n    breed() {\r\n        return Network_1.Network.crossOver(Utils_1.pickRandom(this.members), Utils_1.pickRandom(this.members));\r\n    }\r\n    /**\r\n     * The size of this species\r\n     */\r\n    size() {\r\n        return this.members.size;\r\n    }\r\n    /**\r\n     * Returns the best genome from this species\r\n     */\r\n    getBest() {\r\n        const networks = Array.from(this.members);\r\n        return networks[Utils_1.maxValueIndex(networks.map(genome => { var _a; return (_a = genome.score) !== null && _a !== void 0 ? _a : -Infinity; }))];\r\n    }\r\n    /**\r\n     * to string\r\n     */\r\n    print() {\r\n        console.log(\"Species={Members: \" + this.members.size + \"; Score: \" + this._score + \"; Stagnation: \" + this.stagnation + \"}\");\r\n    }\r\n}\r\nexports.Species = Species;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.NEAT = void 0;\r\nconst TimSort = __importStar(require(\"timsort\"));\r\nconst Species_1 = require(\"./architecture/Species\");\r\nconst Mutation_1 = require(\"./methods/Mutation\");\r\nconst Utils_1 = require(\"./utils/Utils\");\r\n/**\r\n * Runs the NEAT algorithm on group of neural networks.\r\n *\r\n * @constructs Neat\r\n */\r\nclass NEAT {\r\n    /**\r\n     * Constructs a NEAT object.\r\n     *\r\n     * @param options\r\n     */\r\n    constructor(options) {\r\n        if (!options.fitnessFunction) {\r\n            throw new ReferenceError(\"No fitness function given!\");\r\n        }\r\n        this._options = options;\r\n        this.population = [];\r\n        this.species = new Set();\r\n        for (let i = 0; i < this.options.populationSize; i++) {\r\n            this.population.push(this.options.template.copy());\r\n        }\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get options() {\r\n        return this._options;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set options(value) {\r\n        this._options = value;\r\n    }\r\n    /**\r\n     * Mutate a network with a random mutation from the allowed array.\r\n     *\r\n     * @param network The network which will be mutated.\r\n     */\r\n    mutateRandom(network) {\r\n        const allowed = this.options.mutations.filter(method => {\r\n            return (method.constructor.name !== Mutation_1.AddNodeMutation.constructor.name || network.nodes.length < this.options.maxNodes ||\r\n                method.constructor.name !== Mutation_1.AddConnectionMutation.constructor.name || network.connections.size < this.options.maxConnections ||\r\n                method.constructor.name !== Mutation_1.AddGateMutation.constructor.name || network.gates.size < this.options.maxGates);\r\n        });\r\n        network.mutate(Utils_1.pickRandom(allowed), { allowedActivations: this.options.activations });\r\n    }\r\n    /**\r\n     * Evaluates, selects, breeds and mutates population\r\n     *\r\n     * @returns {Network} Fittest network\r\n     */\r\n    evolve() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.genSpecies();\r\n            yield this.evaluate();\r\n            this.sort();\r\n            this.species.forEach(species => species.evaluateScore());\r\n            this.kill(1 - this.options.survivors);\r\n            this.removeExtinctSpecies();\r\n            this.reproduce();\r\n            const elitists = this.population.splice(0, this.options.elitism);\r\n            this.mutate();\r\n            this.population.splice(0, 0, ...elitists);\r\n            if (this.options.training) {\r\n                for (const genome of this.population) {\r\n                    genome.train(this.options.training);\r\n                }\r\n            }\r\n            // evaluate the population\r\n            yield this.evaluate();\r\n            // Sort in order of fitness (fittest first)\r\n            this.sort();\r\n            const fittest = this.population[0].copy();\r\n            fittest.score = this.population[0].score;\r\n            if (this.options.log > 0 && this.options.generation % this.options.log === 0) {\r\n                console.log(\"\\n---------------------------\");\r\n                console.log(\"Generation: \" + this.options.generation + \"; Species: \" + this.species.size + \"; Score: \" + this.population[0].score);\r\n                for (const species of this.species) {\r\n                    species.print();\r\n                }\r\n            }\r\n            // Reset the scores\r\n            this.population.forEach(genome => genome.score = undefined);\r\n            this.options.generation++;\r\n            return fittest;\r\n        });\r\n    }\r\n    /**\r\n     * Mutates the given (or current) population\r\n     *\r\n     * @param {Mutation} [method] A mutation method to mutate the population with. When not specified will pick a random mutation from the set allowed mutations.\r\n     */\r\n    mutate(method) {\r\n        // Elitist genomes should not be included\r\n        this.population\r\n            .filter(() => Math.random() <= this.options.mutationRate)\r\n            .forEach(genome => {\r\n            for (let i = 0; i < this.options.mutationAmount; i++) {\r\n                if (method) {\r\n                    genome.mutate(method);\r\n                }\r\n                else {\r\n                    this.mutateRandom(genome);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    /**\r\n     * Evaluates the current population, basically sets their `.score` property\r\n     *\r\n     * @return {Network} Fittest Network\r\n     */\r\n    evaluate() {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.options.clear) {\r\n                this.population.forEach(genome => genome.clear());\r\n            }\r\n            yield ((_b = (_a = this.options).fitnessFunction) === null || _b === void 0 ? void 0 : _b.call(_a, this.population, this.options.dataset));\r\n            // Sort the population in order of fitness\r\n            this.sort();\r\n            return this.population[0];\r\n        });\r\n    }\r\n    /**\r\n     * Sorts the population by score (descending)\r\n     * @todo implement a quicksort algorithm in utils\r\n     */\r\n    sort() {\r\n        TimSort.sort(this.population, (a, b) => {\r\n            return a.score === undefined || b.score === undefined ? 0 : b.score - a.score;\r\n        });\r\n    }\r\n    /**\r\n     * Returns the fittest genome of the current population\r\n     *\r\n     * @returns {Network} Current population's fittest genome\r\n     */\r\n    getFittest() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.population[this.population.length - 1].score === undefined) {\r\n                yield this.evaluate();\r\n            }\r\n            this.sort();\r\n            return this.population[0];\r\n        });\r\n    }\r\n    /**\r\n     * Returns the average fitness of the current population\r\n     *\r\n     * @returns {number} Average fitness of the current population\r\n     */\r\n    getAverage() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.population[this.population.length - 1].score === undefined) {\r\n                yield this.evaluate();\r\n            }\r\n            let score = 0;\r\n            this.population\r\n                .map(genome => genome.score)\r\n                .forEach(val => score += val !== null && val !== void 0 ? val : 0);\r\n            return score / this.population.length;\r\n        });\r\n    }\r\n    /**\r\n     * Replace the whole population with the new genomes\r\n     * @param genomes the genomes which replace the population\r\n     */\r\n    replacePopulation(genomes) {\r\n        this.population = genomes;\r\n        this.options.populationSize = genomes.length;\r\n    }\r\n    /**\r\n     * Reproduce the population, by replacing the killed networks\r\n     * @private\r\n     */\r\n    reproduce() {\r\n        const speciesArr = Array.from(this.species);\r\n        if (speciesArr.length === 0) {\r\n            return;\r\n        }\r\n        for (let i = 0; i < this.population.length; i++) {\r\n            if (this.population[i].species === null) {\r\n                const selectedSpecies = this.options.selection.select(speciesArr);\r\n                this.population[i] = selectedSpecies.breed();\r\n                selectedSpecies.forcePut(this.population[i]);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Remove empty species\r\n     * @private\r\n     */\r\n    removeExtinctSpecies() {\r\n        for (const species of Array.from(this.species)) {\r\n            if (species.size() <= 1 || species.stagnation > this.options.maxStagnation) {\r\n                species.members.forEach(member => member.species = null);\r\n                this.species.delete(species);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Kill bad networks\r\n     * @param killRate\r\n     * @private\r\n     */\r\n    kill(killRate) {\r\n        this.species.forEach(species => species.kill(killRate));\r\n    }\r\n    /**\r\n     * Generate species\r\n     * @private\r\n     */\r\n    genSpecies() {\r\n        this.species.forEach(species => species.reset());\r\n        this.population.filter(genome => genome.species === null).forEach(genome => {\r\n            let found = false;\r\n            for (const species of Array.from(this.species)) {\r\n                if (species.put(genome, this.options.c1, this.options.c2, this.options.c3, this.options.speciesDistanceThreshold)) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found) {\r\n                this.species.add(new Species_1.Species(genome));\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.NEAT = NEAT;\r\n","\"use strict\";\r\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n}));\r\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n});\r\nvar __importStar = (this && this.__importStar) || function (mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n};\r\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n};\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Network = void 0;\r\nconst threads_1 = require(\"threads\");\r\nconst dist_1 = require(\"threads/dist\");\r\nrequire(\"threads/register\");\r\nconst TimSort = __importStar(require(\"timsort\"));\r\nconst NodeType_1 = require(\"../enums/NodeType\");\r\nconst EvolveOptions_1 = require(\"../interfaces/EvolveOptions\");\r\nconst Loss_1 = require(\"../methods/Loss\");\r\nconst Mutation_1 = require(\"../methods/Mutation\");\r\nconst NEAT_1 = require(\"../NEAT\");\r\nconst Utils_1 = require(\"../utils/Utils\");\r\nconst Node_1 = require(\"./Node\");\r\n/**\r\n * Create a neural network\r\n *\r\n * Networks are easy to create, all you need to specify is an `input` and an `output` size.\r\n *\r\n * @constructs Network\r\n */\r\nclass Network {\r\n    constructor(inputSize, outputSize) {\r\n        this.inputSize = inputSize;\r\n        this.outputSize = outputSize;\r\n        this.nodes = [];\r\n        this.connections = new Set();\r\n        this.gates = new Set();\r\n        this.score = undefined;\r\n        this.species = null;\r\n        // Create input and output nodes\r\n        for (let i = 0; i < inputSize; i++) {\r\n            this.nodes.push(new Node_1.Node(NodeType_1.NodeType.INPUT));\r\n        }\r\n        for (let i = 0; i < outputSize; i++) {\r\n            this.nodes.push(new Node_1.Node(NodeType_1.NodeType.OUTPUT));\r\n        }\r\n        // Connect input and output nodes\r\n        for (let i = 0; i < this.inputSize; i++) {\r\n            for (let j = this.inputSize; j < this.outputSize + this.inputSize; j++) {\r\n                // https://stats.stackexchange.com/a/248040/147931\r\n                const weight = (Math.random() - 0.5) * this.inputSize * Math.sqrt(2 / this.inputSize);\r\n                this.connect(this.nodes[i], this.nodes[j], weight);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Convert a json object to a network\r\n     *\r\n     * @param {{input:{number},output:{number},dropout:{number},nodes:Array<object>,connections:Array<object>}} json A network represented as a json object\r\n     *\r\n     * @returns {Network} Network A reconstructed network\r\n     */\r\n    static fromJSON(json) {\r\n        const network = new Network(json.inputSize, json.outputSize);\r\n        network.nodes = [];\r\n        network.connections.clear();\r\n        json.nodes\r\n            .map(nodeJSON => new Node_1.Node().fromJSON(nodeJSON))\r\n            .forEach(node => network.nodes[node.index] = node);\r\n        json.connections.forEach((jsonConnection) => {\r\n            const connection = network.connect(network.nodes[jsonConnection.fromIndex], network.nodes[jsonConnection.toIndex], jsonConnection.weight);\r\n            if (jsonConnection.gateNodeIndex != null) {\r\n                network.addGate(network.nodes[jsonConnection.gateNodeIndex], connection);\r\n            }\r\n        });\r\n        return network;\r\n    }\r\n    /**\r\n     * Create an offspring from two parent networks.\r\n     *\r\n     * Networks are not required to have the same size, however input and output size should be the same!\r\n     *\r\n     * @todo Add custom [crossover](crossover) method customization\r\n     *\r\n     * @param {Network} network1 First parent network\r\n     * @param {Network} network2 Second parent network\r\n     *\r\n     * @returns {Network} New network created from mixing parent networks\r\n     */\r\n    static crossOver(network1, network2) {\r\n        var _a, _b;\r\n        if (network1.inputSize !== network2.inputSize || network1.outputSize !== network2.outputSize) {\r\n            throw new Error(\"Networks don`t have the same input/output size!\");\r\n        }\r\n        // Initialise offspring\r\n        const offspring = new Network(network1.inputSize, network1.outputSize);\r\n        offspring.connections.clear(); // clear\r\n        offspring.nodes = []; // clear\r\n        // Save scores and create a copy\r\n        const score1 = (_a = network1.score) !== null && _a !== void 0 ? _a : 0;\r\n        const score2 = (_b = network2.score) !== null && _b !== void 0 ? _b : 0;\r\n        // Determine offspring node size\r\n        let offspringSize;\r\n        if (score1 === score2) {\r\n            const max = Math.max(network1.nodes.length, network2.nodes.length);\r\n            const min = Math.min(network1.nodes.length, network2.nodes.length);\r\n            offspringSize = Utils_1.randInt(min, max + 1); // [min,max]\r\n        }\r\n        else if (score1 > score2) {\r\n            offspringSize = network1.nodes.length;\r\n        }\r\n        else {\r\n            offspringSize = network2.nodes.length;\r\n        }\r\n        const inputSize = network1.inputSize;\r\n        const outputSize = network1.outputSize;\r\n        // set node indices\r\n        for (let i = 0; i < network1.nodes.length; i++) {\r\n            network1.nodes[i].index = i;\r\n        }\r\n        // set node indices\r\n        for (let i = 0; i < network2.nodes.length; i++) {\r\n            network2.nodes[i].index = i;\r\n        }\r\n        // Assign nodes from parents to offspring\r\n        for (let i = 0; i < offspringSize; i++) {\r\n            let chosenNode;\r\n            let chosenNodeType = null;\r\n            // decide what type of node is needed first check for input and output nodes and fill up with hidden nodes\r\n            if (i < inputSize) { // pick input node\r\n                chosenNodeType = NodeType_1.NodeType.INPUT;\r\n                const sourceNetwork = Utils_1.randBoolean() ? network1 : network2;\r\n                let inputNumber = -1;\r\n                let j = -1;\r\n                while (inputNumber < i) {\r\n                    if (j++ >= sourceNetwork.nodes.length) {\r\n                        throw RangeError('something is wrong with the size of the input');\r\n                    }\r\n                    if (sourceNetwork.nodes[j].isInputNode()) {\r\n                        inputNumber++;\r\n                    }\r\n                }\r\n                chosenNode = sourceNetwork.nodes[j];\r\n            }\r\n            else if (i < inputSize + outputSize) { // pick output node\r\n                chosenNodeType = NodeType_1.NodeType.OUTPUT;\r\n                const sourceNetwork = Utils_1.randBoolean() ? network1 : network2;\r\n                let outputNumber = -1;\r\n                let j = -1;\r\n                while (outputNumber < i - inputSize) {\r\n                    j++;\r\n                    if (j >= sourceNetwork.nodes.length) {\r\n                        throw RangeError('something is wrong with the size of the output');\r\n                    }\r\n                    if (sourceNetwork.nodes[j].isOutputNode()) {\r\n                        outputNumber++;\r\n                    }\r\n                }\r\n                chosenNode = sourceNetwork.nodes[j];\r\n            }\r\n            else { // pick hidden node\r\n                chosenNodeType = NodeType_1.NodeType.HIDDEN;\r\n                let sourceNetwork;\r\n                if (i >= network1.nodes.length) {\r\n                    sourceNetwork = network2;\r\n                }\r\n                else if (i >= network2.nodes.length) {\r\n                    sourceNetwork = network1;\r\n                }\r\n                else {\r\n                    sourceNetwork = Utils_1.randBoolean() ? network1 : network2;\r\n                }\r\n                chosenNode = Utils_1.pickRandom(sourceNetwork.nodes);\r\n            }\r\n            const newNode = new Node_1.Node(chosenNodeType);\r\n            newNode.bias = chosenNode.bias;\r\n            newNode.squash = chosenNode.squash;\r\n            offspring.nodes.push(newNode);\r\n        }\r\n        // Create arrays of connection genes\r\n        const n1connections = [];\r\n        const n2connections = [];\r\n        // Add the connections of network 1\r\n        network1.connections.forEach(connection => {\r\n            n1connections[Utils_1.pairing(connection.from.index, connection.to.index)] = connection.toJSON();\r\n        });\r\n        // Add the connections of network 2\r\n        network2.connections.forEach(connection => {\r\n            n2connections[Utils_1.pairing(connection.from.index, connection.to.index)] = connection.toJSON();\r\n        });\r\n        // Split common conn genes from disjoint or excess conn genes\r\n        const connections = [];\r\n        const keys1 = Object.keys(n1connections);\r\n        const keys2 = Object.keys(n2connections);\r\n        for (let i = keys1.length - 1; i >= 0; i--) {\r\n            if (n2connections[parseInt(keys1[i])] !== undefined) {\r\n                connections.push(Utils_1.randBoolean() ? n1connections[parseInt(keys1[i])] : n2connections[parseInt(keys1[i])]);\r\n                n2connections[parseInt(keys1[i])] = undefined;\r\n            }\r\n            else if (score1 >= score2) {\r\n                connections.push(n1connections[parseInt(keys1[i])]);\r\n            }\r\n        }\r\n        // Excess/disjoint gene\r\n        if (score2 >= score1) {\r\n            keys2\r\n                .map(key => parseInt(key)) // convert to numbers\r\n                .map(key => n2connections[key]) // get the connection\r\n                .filter(conn => conn !== undefined) // filter out undefined connections\r\n                .forEach(conn => connections.push(conn)); // add the filtered connections\r\n        }\r\n        // Add common conn genes uniformly\r\n        connections.forEach(connectionJSON => {\r\n            if (connectionJSON !== undefined && connectionJSON.toIndex < offspringSize && connectionJSON.fromIndex < offspringSize) {\r\n                const from = offspring.nodes[connectionJSON.fromIndex];\r\n                const to = offspring.nodes[connectionJSON.toIndex];\r\n                const connection = offspring.connect(from, to, connectionJSON.weight);\r\n                if (connectionJSON.gateNodeIndex !== null && connectionJSON.gateNodeIndex < offspringSize) {\r\n                    offspring.addGate(offspring.nodes[connectionJSON.gateNodeIndex], connection);\r\n                }\r\n            }\r\n        });\r\n        return offspring;\r\n    }\r\n    /**\r\n     * Returns a copy of Network.\r\n     * @returns {Network} Returns an identical network\r\n     */\r\n    copy() {\r\n        return Network.fromJSON(this.toJSON());\r\n    }\r\n    /**\r\n     * Connects a Node to another Node or Group in the network\r\n     *\r\n     * @param {Node} from The source Node\r\n     * @param {Node} to The destination Node or Group\r\n     * @param {number} [weight=0] An initial weight for the connections to be formed\r\n     *\r\n     * @returns {Connection[]} An array of the formed connections\r\n     */\r\n    connect(from, to, weight = 0) {\r\n        const connection = from.connect(to, weight); // run node-level connect\r\n        this.connections.add(connection); // add it to the array\r\n        return connection;\r\n    }\r\n    /**\r\n     * Activates the network\r\n     *\r\n     * It will activate all the nodes in activation order and produce an output.\r\n     *\r\n     * @param {number[]} [input] Input values to activate nodes with\r\n     * @param options\r\n     * @returns {number[]} Squashed output values\r\n     */\r\n    activate(input, options = {}) {\r\n        var _a, _b;\r\n        if (input.length !== this.inputSize) {\r\n            throw new RangeError(\"Input size of dataset is different to network input size!\");\r\n        }\r\n        // get default value if no value is given\r\n        options.dropoutRate = (_a = options.dropoutRate) !== null && _a !== void 0 ? _a : 0;\r\n        options.trace = (_b = options.trace) !== null && _b !== void 0 ? _b : true;\r\n        this.nodes\r\n            .filter(node => node.isInputNode()) // only input nodes\r\n            .forEach((node, index) => node.activate(input[index], options.trace)); // activate them with the input\r\n        this.nodes\r\n            .filter(node => node.isHiddenNode()) // only hidden nodes\r\n            .forEach((node) => {\r\n            if (options.dropoutRate) {\r\n                node.mask = Math.random() >= options.dropoutRate ? 1 : 0;\r\n            }\r\n            node.activate(undefined, options.trace); // activate them\r\n        });\r\n        return this.nodes\r\n            .filter(node => node.isOutputNode()) // only output nodes\r\n            .map((node) => node.activate(undefined, options.trace)); // map them to there activation value will give the network's output\r\n    }\r\n    /**\r\n     * Backpropagate the network\r\n     *\r\n     * This function allows you to teach the network. If you want to do more complex training, use the `network.train()` function.\r\n     *\r\n     * @param {number[]} target Ideal values of the previous activate. Will use the difference to improve the weights\r\n     * @param options More option for propagation\r\n     */\r\n    propagate(target, options = {}) {\r\n        var _a, _b, _c;\r\n        // get default value if value isn't given\r\n        options.rate = (_a = options.rate) !== null && _a !== void 0 ? _a : 0.3;\r\n        options.momentum = (_b = options.momentum) !== null && _b !== void 0 ? _b : 0;\r\n        options.update = (_c = options.update) !== null && _c !== void 0 ? _c : false;\r\n        if (target.length !== this.outputSize) {\r\n            throw new Error(`Output target length should match network output length`);\r\n        }\r\n        // Backpropagation: output -> hidden -> input\r\n        // propagate through the output nodes\r\n        this.nodes\r\n            .filter(node => node.isOutputNode()) // only output nodes\r\n            .forEach((node, index) => node.propagate(target[index], options)); // propagate\r\n        // propagate backwards through the hidden nodes\r\n        for (let i = this.nodes.length - 1; i >= 0; i--) {\r\n            if (this.nodes[i].isHiddenNode()) { // only hidden nodes\r\n                this.nodes[i].propagate(undefined, options);\r\n            }\r\n        }\r\n        // propagate through the input nodes\r\n        this.nodes\r\n            .filter(node => node.isInputNode()) // only input nodes\r\n            .forEach(node => node.propagate(undefined, options)); // propagate\r\n    }\r\n    /**\r\n     * Clear the context of the network\r\n     */\r\n    clear() {\r\n        this.nodes.forEach(node => node.clear());\r\n    }\r\n    /**\r\n     * Removes the connection of the `from` node to the `to` node\r\n     *\r\n     * @param {Node} from Source node\r\n     * @param {Node} to Destination node\r\n     */\r\n    disconnect(from, to) {\r\n        // remove the connection network-level\r\n        this.connections.forEach((conn) => {\r\n            if (conn.from === from && conn.to === to) {\r\n                if (conn.gateNode !== null) {\r\n                    this.removeGate(conn); // remove possible gate\r\n                }\r\n                this.connections.delete(conn); // remove connection from array\r\n            }\r\n        });\r\n        // disconnect node-level\r\n        return from.disconnect(to);\r\n    }\r\n    /**\r\n     * Makes a network node gate a connection\r\n     *\r\n     * @param {Node} node Gating node\r\n     * @param {Connection} connection Connection to gate with node\r\n     */\r\n    addGate(node, connection) {\r\n        if (this.nodes.indexOf(node) === -1) {\r\n            throw new ReferenceError(`This node is not part of the network!`);\r\n        }\r\n        else if (connection.gateNode != null) {\r\n            return;\r\n        }\r\n        node.addGate(connection);\r\n        this.gates.add(connection);\r\n    }\r\n    /**\r\n     * Remove the gate of a connection.\r\n     *\r\n     * @param {Connection} connection Connection to remove gate from\r\n     */\r\n    removeGate(connection) {\r\n        if (!this.gates.has(connection)) {\r\n            throw new Error(`This connection is not gated!`);\r\n        }\r\n        this.gates.delete(connection);\r\n        if (connection.gateNode != null) {\r\n            connection.gateNode.removeGate(connection);\r\n        }\r\n    }\r\n    /**\r\n     * Removes a node from a network, all its connections will be redirected. If it gates a connection, the gate will be removed.\r\n     *\r\n     * @param {Node} node Node to remove from the network\r\n     * @param keepGates\r\n     */\r\n    removeNode(node, keepGates = new Mutation_1.SubNodeMutation().keepGates) {\r\n        if (!this.nodes.includes(node)) {\r\n            throw new ReferenceError(`This node does not exist in the network!`);\r\n        }\r\n        this.disconnect(node, node); // remove self connection\r\n        const inputs = []; // keep track\r\n        const gates = []; // keep track\r\n        const outputs = []; // keep track\r\n        const connections = []; // keep track\r\n        // read all inputs from node and keep track of the nodes that gate the incoming connection\r\n        node.incoming.forEach(connection => {\r\n            if (keepGates && connection.gateNode !== null && connection.gateNode !== node) {\r\n                gates.push(connection.gateNode);\r\n            }\r\n            inputs.push(connection.from);\r\n            this.disconnect(connection.from, node);\r\n        });\r\n        // read all outputs from node and keep track of the nodes that gate the outgoing connection\r\n        node.outgoing.forEach(connection => {\r\n            if (keepGates && connection.gateNode !== null && connection.gateNode !== node) {\r\n                gates.push(connection.gateNode);\r\n            }\r\n            outputs.push(connection.to);\r\n            this.disconnect(node, connection.to);\r\n        });\r\n        // add all connections the node has\r\n        inputs.forEach(input => {\r\n            outputs.forEach(output => {\r\n                if (!input.isProjectingTo(output)) {\r\n                    connections.push(this.connect(input, output));\r\n                }\r\n            });\r\n        });\r\n        // as long as there are gates and connections\r\n        while (gates.length > 0 && connections.length > 0) {\r\n            const gate = gates.shift(); // take a gate node and remove it from the array\r\n            if (gate === undefined) {\r\n                continue;\r\n            }\r\n            const connection = Utils_1.pickRandom(connections); // take a random connection\r\n            this.addGate(gate, connection); // gate the connection with the gate node\r\n            Utils_1.removeFromArray(connections, connection); // remove the connection from the array\r\n        }\r\n        // remove every gate the node has\r\n        node.gated.forEach(this.removeGate);\r\n        Utils_1.removeFromArray(this.nodes, node); // remove the node from the nodes array\r\n    }\r\n    /**\r\n     * Mutates the network with the given method.\r\n     *\r\n     * @param {Mutation} method [Mutation method](mutation)\r\n     * @param {object} options\r\n     * @param {number} [options.maxNodes]\r\n     * @param {number} [options.maxConnections]\r\n     * @param {number} [options.maxGates] Maximum amount of Gates a network can grow to\r\n     */\r\n    mutate(method, options) {\r\n        method.mutate(this, options);\r\n    }\r\n    /**\r\n     * Selects a random mutation method and returns a mutated copy of the network. Warning! Mutates network directly.\r\n     *\r\n     * @param {Mutation[]} [allowedMethods=methods.mutation.ALL] An array of [Mutation methods](mutation) to automatically pick from\r\n     * @param {object} options\r\n     * @param {number} [options.maxNodes] Maximum amount of [Nodes](node) a network can grow to\r\n     * @param {number} [options.maxConnections] Maximum amount of [Connections](connection) a network can grow to\r\n     * @param {number} [options.maxGates] Maximum amount of Gates a network can grow to\r\n     */\r\n    mutateRandom(allowedMethods = Mutation_1.ALL_MUTATIONS, options = {}) {\r\n        if (allowedMethods.length === 0) {\r\n            return;\r\n        }\r\n        // mutate the network with a random allowed mutation\r\n        this.mutate(Utils_1.pickRandom(allowedMethods), options);\r\n    }\r\n    /**\r\n     * Train the given data to this network\r\n     *\r\n     * @param {TrainOptions} options Options used to train network\r\n     *\r\n     * @returns {{error:{number},iterations:{number},time:{number}}} A summary object of the network's performance\r\n     */\r\n    train(options) {\r\n        if (options.dataset[0].input.length !== this.inputSize || options.dataset[0].output.length !== this.outputSize) {\r\n            throw new Error(`Dataset input/output size should be same as network input/output size!`);\r\n        }\r\n        const start = Date.now();\r\n        if (options.iterations <= 0 && options.error <= 0) {\r\n            throw new Error(`At least one of the following options must be specified: error, iterations`);\r\n        }\r\n        // Split into trainingSet and testSet if cross validation is enabled\r\n        let trainingSetSize;\r\n        let trainingSet;\r\n        let testSet;\r\n        if (options.crossValidateTestSize > 0) {\r\n            trainingSetSize = Math.ceil((1 - options.crossValidateTestSize) * options.dataset.length);\r\n            trainingSet = options.dataset.slice(0, trainingSetSize);\r\n            testSet = options.dataset.slice(trainingSetSize);\r\n        }\r\n        else {\r\n            trainingSet = options.dataset;\r\n            testSet = [];\r\n        }\r\n        let currentTrainingRate;\r\n        let iterationCount = 0;\r\n        let error = 1;\r\n        // train until the target error is reached or the target iterations are reached\r\n        while (error > options.error && (options.iterations <= 0 || iterationCount < options.iterations)) {\r\n            iterationCount++;\r\n            // update the rate according to the rate policy\r\n            currentTrainingRate = options.rate.calc(iterationCount);\r\n            // train a single epoch\r\n            error = this.trainEpoch({\r\n                dataset: trainingSet,\r\n                batchSize: options.batchSize,\r\n                trainingRate: currentTrainingRate,\r\n                momentum: options.momentum,\r\n                loss: options.loss,\r\n                dropoutRate: options.dropout\r\n            });\r\n            if (options.clear) {\r\n                this.clear();\r\n            }\r\n            // Run test with the testSet, if cross validation is enabled\r\n            if (options.crossValidateTestSize > 0) {\r\n                error = this.test(testSet, options.loss);\r\n                if (options.clear) {\r\n                    this.clear();\r\n                }\r\n            }\r\n            if (options.shuffle) {\r\n                Utils_1.shuffle(options.dataset);\r\n            }\r\n            if (options.log > 0 && iterationCount % options.log === 0) {\r\n                console.log(`iteration number`, iterationCount, `error`, error, `training rate`, currentTrainingRate);\r\n            }\r\n            if (options.schedule && iterationCount % options.schedule.iterations === 0) {\r\n                options.schedule.function(error, iterationCount);\r\n            }\r\n        }\r\n        if (options.clear) {\r\n            this.clear();\r\n        }\r\n        return {\r\n            error,\r\n            iterations: iterationCount,\r\n            time: Date.now() - start\r\n        };\r\n    }\r\n    /**\r\n     * Tests a set and returns the error and elapsed time\r\n     *\r\n     * @param {Array<{input:number[],output:number[]}>} dataset A set of input values and ideal output values to test the network against\r\n     * @param {lossType} [loss=MSELoss] The [loss function](https://en.wikipedia.org/wiki/Loss_function) used to determine network error\r\n     *\r\n     * @returns {number} A summary object of the network's performance\r\n     */\r\n    test(dataset, loss = Loss_1.MSELoss) {\r\n        let error = 0;\r\n        for (const entry of dataset) {\r\n            const input = entry.input;\r\n            const target = entry.output;\r\n            const output = this.activate(input, { trace: false });\r\n            error += loss(target, output);\r\n        }\r\n        return error / dataset.length;\r\n    }\r\n    /**\r\n     * Convert the network to a json object\r\n     *\r\n     * @returns {NetworkJSON} The network represented as a json object\r\n     */\r\n    toJSON() {\r\n        const json = {\r\n            nodes: [],\r\n            connections: [],\r\n            inputSize: this.inputSize,\r\n            outputSize: this.outputSize,\r\n        };\r\n        // set node indices\r\n        for (let i = 0; i < this.nodes.length; i++) {\r\n            this.nodes[i].index = i;\r\n        }\r\n        // convert all nodes to json and add the to the json object\r\n        this.nodes.forEach(node => {\r\n            json.nodes.push(node.toJSON());\r\n            if (node.selfConnection.weight !== 0) {\r\n                // if there is a self connection\r\n                // add it to the json object\r\n                json.connections.push(node.selfConnection.toJSON());\r\n            }\r\n        });\r\n        this.connections.forEach(conn => {\r\n            json.connections.push(conn.toJSON());\r\n        });\r\n        return json;\r\n    }\r\n    /**\r\n     * Evolves the network to reach a lower error on a dataset using the [NEAT algorithm](http://nn.cs.utexas.edu/downloads/papers/stanley.ec02.pdf)\r\n     *\r\n     * If both `iterations` and `error` options are unset, evolve will default to `iterations` as an end condition.\r\n     *\r\n     * @param {object} [options] Configuration options\r\n     *\r\n     * @returns {{error:{number},iterations:{number},time:{number}}} A summary object of the network's performance. <br /> Properties include: `error` - error of the best genome, `iterations` - generations used to evolve networks, `time` - clock time elapsed while evolving\r\n     */\r\n    evolve(options = new EvolveOptions_1.EvolveOptions()) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!options.fitnessFunction && options.dataset && (options.dataset[0].input.length !== this.inputSize || options.dataset[0].output.length !== this.outputSize)) {\r\n                throw new Error(`Dataset input/output size should be same as network input/output size!`);\r\n            }\r\n            // set options to default if necessary\r\n            options.input = this.inputSize;\r\n            options.output = this.outputSize;\r\n            const start = Date.now();\r\n            // @ts-ignore\r\n            let workerPool;\r\n            if (!options.fitnessFunction) {\r\n                // if no fitness function is given\r\n                // create default one\r\n                // Serialize the dataset using JSON\r\n                const serializedDataSet = JSON.stringify(options.dataset);\r\n                const lossIndex = Object.values(Loss_1.ALL_LOSSES).indexOf(options.loss);\r\n                // init a pool of workers\r\n                workerPool = dist_1.Pool(() => threads_1.spawn(new threads_1.Worker(\"../multithreading/TestWorker\")), options.threads);\r\n                options.fitnessFunction = function (population) {\r\n                    return __awaiter(this, void 0, void 0, function* () {\r\n                        for (const genome of population) {\r\n                            // add a task to the workerPool's queue\r\n                            workerPool.queue((test) => __awaiter(this, void 0, void 0, function* () {\r\n                                if (genome === undefined) {\r\n                                    throw new ReferenceError();\r\n                                }\r\n                                // test the genome\r\n                                genome.score = -(yield test(serializedDataSet, JSON.stringify(genome.toJSON()), lossIndex));\r\n                            }));\r\n                        }\r\n                        yield workerPool.completed(); // wait until every task is done\r\n                    });\r\n                };\r\n            }\r\n            options.template = this; // set this network as template for first generation\r\n            const neat = new NEAT_1.NEAT(options);\r\n            let error;\r\n            let bestFitness = 0;\r\n            let bestGenome = this;\r\n            // run until error goal is reached or iteration goal is reached\r\n            do {\r\n                const fittest = yield neat.evolve(); // run one generation\r\n                if (!fittest.score) {\r\n                    throw new ReferenceError();\r\n                }\r\n                error = fittest.score;\r\n                if (neat.options.generation === 1 || fittest.score > bestFitness) {\r\n                    bestFitness = fittest.score;\r\n                    bestGenome = fittest;\r\n                }\r\n                if (options.schedule && neat.options.generation % options.schedule.iterations === 0) {\r\n                    options.schedule.function(fittest.score, -error, neat.options.generation);\r\n                }\r\n            } while (error < -options.error && (options.iterations === 0 || neat.options.generation < options.iterations));\r\n            if (bestGenome !== undefined) {\r\n                // set this network to the fittest from NEAT\r\n                this.nodes = bestGenome.nodes;\r\n                this.connections = bestGenome.connections;\r\n                this.gates = bestGenome.gates;\r\n                if (options.clear) {\r\n                    this.clear();\r\n                }\r\n            }\r\n            if (workerPool) {\r\n                yield workerPool.terminate(); // stop all processes\r\n            }\r\n            return {\r\n                error: -error,\r\n                iterations: neat.options.generation,\r\n                time: Date.now() - start,\r\n            };\r\n        });\r\n    }\r\n    /**\r\n     * Distance function\r\n     * @param g2 other network\r\n     * @param c1\r\n     * @param c2\r\n     * @param c3\r\n     */\r\n    distance(g2, c1, c2, c3) {\r\n        let g1 = this;\r\n        // set node indices\r\n        for (let i = 0; i < g1.nodes.length; i++) {\r\n            g1.nodes[i].index = i;\r\n        }\r\n        // set node indices\r\n        for (let i = 0; i < g2.nodes.length; i++) {\r\n            g2.nodes[i].index = i;\r\n        }\r\n        let indexG1 = 0;\r\n        let indexG2 = 0;\r\n        const connections1 = Array.from(g1.connections).filter(conn => conn !== undefined);\r\n        const connections2 = Array.from(g2.connections).filter(conn => conn !== undefined);\r\n        TimSort.sort(connections1, (a, b) => {\r\n            return a.getInnovationID() - b.getInnovationID();\r\n        });\r\n        TimSort.sort(connections2, (a, b) => {\r\n            return a.getInnovationID() - b.getInnovationID();\r\n        });\r\n        const highestInnovationID1 = connections1[connections1.length - 1].getInnovationID();\r\n        const highestInnovationID2 = connections2[connections2.length - 1].getInnovationID();\r\n        if (highestInnovationID1 < highestInnovationID2) {\r\n            const temp = g1;\r\n            g1 = g2;\r\n            g2 = temp;\r\n        }\r\n        let disjointGenes = 0;\r\n        let totalWeightDiff = 0;\r\n        let similarGenes = 0;\r\n        while (indexG1 < connections1.length && indexG2 < connections2.length) {\r\n            const gene1 = connections1[indexG1];\r\n            const gene2 = connections2[indexG2];\r\n            if (gene1 === undefined || gene2 === undefined) {\r\n                throw Error(\"HERE\");\r\n            }\r\n            const in1 = gene1.getInnovationID();\r\n            const in2 = gene2.getInnovationID();\r\n            if (in1 === in2) {\r\n                // similarGenes\r\n                indexG1++;\r\n                indexG2++;\r\n                totalWeightDiff += Math.abs(gene1.weight - gene2.weight);\r\n                similarGenes++;\r\n            }\r\n            else if (indexG1 > indexG2) {\r\n                // disjoint of b\r\n                indexG2++;\r\n                disjointGenes++;\r\n            }\r\n            else {\r\n                // disjoint of a\r\n                indexG1++;\r\n                disjointGenes++;\r\n            }\r\n        }\r\n        totalWeightDiff /= similarGenes;\r\n        const excessGenes = g1.connections.size - indexG1;\r\n        let N = Math.max(g1.connections.size, g2.connections.size);\r\n        if (N < 20) {\r\n            N = 1;\r\n        }\r\n        return c1 * excessGenes / N + c2 * disjointGenes / N + c3 * totalWeightDiff;\r\n    }\r\n    /**\r\n     * Performs one training epoch and returns the error - this is a private function used in `self.train`\r\n     *\r\n     * @private\r\n     *\r\n     * @returns {number}\r\n     */\r\n    trainEpoch(options) {\r\n        let errorSum = 0;\r\n        for (let i = 0; i < options.dataset.length; i++) {\r\n            const input = options.dataset[i].input;\r\n            const correctOutput = options.dataset[i].output;\r\n            const update = (i + 1) % options.batchSize === 0 || i + 1 === options.dataset.length;\r\n            const output = this.activate(input, { dropoutRate: options.dropoutRate });\r\n            this.propagate(correctOutput, { rate: options.trainingRate, momentum: options.momentum, update });\r\n            errorSum += options.loss(correctOutput, output);\r\n        }\r\n        return errorSum / options.dataset.length;\r\n    }\r\n}\r\nexports.Network = Network;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.Architect = void 0;\r\nconst InputLayer_1 = require(\"./Layers/CoreLayers/InputLayer\");\r\nconst OutputLayer_1 = require(\"./Layers/CoreLayers/OutputLayer\");\r\nconst Layer_1 = require(\"./Layers/Layer\");\r\nconst Network_1 = require(\"./Network\");\r\n/**\r\n * Architect constructs multilayer networks with various types of layers.\r\n */\r\nclass Architect {\r\n    constructor() {\r\n        this.layers = [];\r\n    }\r\n    /**\r\n     * Adds a layer to the architect.\r\n     *\r\n     * @param layer The layer\r\n     * @param incomingConnectionType The incoming connection to this layer\r\n     * @returns this object to function as builder class\r\n     */\r\n    addLayer(layer, incomingConnectionType) {\r\n        const connectionType = incomingConnectionType !== null && incomingConnectionType !== void 0 ? incomingConnectionType : layer.getDefaultIncomingConnectionType();\r\n        if (!layer.connectionTypeisAllowed(connectionType)) {\r\n            throw new ReferenceError(\"Connection type \" + connectionType + \" is not allowed at layer \" + layer.constructor.name);\r\n        }\r\n        this.layers.push({\r\n            layer,\r\n            incomingConnectionType: connectionType\r\n        });\r\n        return this; // function as builder class\r\n    }\r\n    /**\r\n     * Build the network from the layers added to the architect.\r\n     *\r\n     * @returns the constructed network\r\n     */\r\n    buildModel() {\r\n        if (!(this.layers[0].layer instanceof InputLayer_1.InputLayer)) {\r\n            throw new ReferenceError(\"First layer has to be a InputLayer! Currently is: \" + this.layers[0].layer.constructor.name);\r\n        }\r\n        if (!(this.layers[this.layers.length - 1].layer instanceof OutputLayer_1.OutputLayer)) {\r\n            throw new ReferenceError(\"Last layer has to be a OutputLayer! Currently is: \" + this.layers[this.layers.length - 1].layer.constructor.name);\r\n        }\r\n        const inputSize = this.layers[0].layer.nodes.length;\r\n        const outputSize = this.layers[this.layers.length - 1].layer.nodes.length;\r\n        const network = new Network_1.Network(inputSize, outputSize);\r\n        network.nodes = [];\r\n        network.connections.clear();\r\n        for (let i = 0; i < this.layers.length - 1; i++) {\r\n            Layer_1.Layer.connect(this.layers[i].layer, this.layers[i + 1].layer, this.layers[i + 1].incomingConnectionType).forEach(conn => network.connections.add(conn));\r\n            network.nodes.push(...this.layers[i].layer.nodes);\r\n            this.layers[i].layer.connections.forEach(conn => network.connections.add(conn));\r\n            this.layers[i].layer.gates.forEach(conn => network.gates.add(conn));\r\n        }\r\n        network.nodes.push(...this.layers[this.layers.length - 1].layer.nodes);\r\n        return network;\r\n    }\r\n}\r\nexports.Architect = Architect;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ActivationNode = void 0;\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nconst ConstantNode_1 = require(\"./ConstantNode\");\r\n/**\r\n * Activation node\r\n */\r\nclass ActivationNode extends ConstantNode_1.ConstantNode {\r\n    constructor() {\r\n        super();\r\n    }\r\n    /**\r\n     * Actives the node.\r\n     *\r\n     * When a neuron activates, it computes its state from all its input connections and 'squashes' it using its activation function, and returns the output (activation).\r\n     *\r\n     * You can also provide the activation (a float between 0 and 1) as a parameter, which is useful for neurons in the input layer.\r\n     *\r\n     * @returns A neuron's output value\r\n     */\r\n    activate() {\r\n        this.old = this.state;\r\n        const incomingStates = Array.from(this.incoming).map(conn => conn.from.activation * conn.weight * conn.gain);\r\n        if (incomingStates.length !== 1) {\r\n            throw new ReferenceError(\"Only 1 incoming connections is allowed!\");\r\n        }\r\n        this.state = incomingStates[0];\r\n        this.activation = this.squash(this.state, false) * this.mask;\r\n        this.derivativeState = this.squash(this.state, true);\r\n        return this.activation;\r\n    }\r\n    /**\r\n     * Backpropagate the error (a.k.a. learn).\r\n     *\r\n     * After an activation, you can teach the node what should have been the correct output (a.k.a. train). This is done by backpropagating. [Momentum](https://www.willamette.edu/~gorr/classes/cs449/momrate.html) adds a fraction of the previous weight update to the current one. When the gradient keeps pointing in the same direction, this will increase the size of the steps taken towards the minimum.\r\n     *\r\n     * If you combine a high learning rate with a lot of momentum, you will rush past the minimum (of the error function) with huge steps. It is therefore often necessary to reduce the global learning rate  when using a lot of momentum (m close to 1).\r\n     *\r\n     * @param target The target value (i.e. \"the value the network SHOULD have given\")\r\n     * @param options More options for propagation\r\n     */\r\n    propagate(target, options) {\r\n        var _a, _b, _c;\r\n        options.momentum = (_a = options.momentum) !== null && _a !== void 0 ? _a : 0;\r\n        options.rate = (_b = options.rate) !== null && _b !== void 0 ? _b : 0.3;\r\n        options.update = (_c = options.update) !== null && _c !== void 0 ? _c : true;\r\n        const connectionsStates = Array.from(this.outgoing).map(conn => conn.to.errorResponsibility * conn.weight * conn.gain);\r\n        this.errorResponsibility = this.errorProjected = Utils_1.sum(connectionsStates) * this.derivativeState;\r\n        this.incoming.forEach(connection => {\r\n            var _a, _b;\r\n            // calculate gradient\r\n            let gradient = this.errorProjected * connection.eligibility;\r\n            connection.xTrace.forEach((value, key) => {\r\n                gradient += key.errorResponsibility * value;\r\n            });\r\n            connection.deltaWeightsTotal += ((_a = options.rate) !== null && _a !== void 0 ? _a : 0.3) * gradient * this.mask;\r\n            if (options.update) {\r\n                connection.deltaWeightsTotal += ((_b = options.momentum) !== null && _b !== void 0 ? _b : 0) * connection.deltaWeightsPrevious;\r\n                connection.weight += connection.deltaWeightsTotal;\r\n                connection.deltaWeightsPrevious = connection.deltaWeightsTotal;\r\n                connection.deltaWeightsTotal = 0;\r\n            }\r\n        });\r\n    }\r\n}\r\nexports.ActivationNode = ActivationNode;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.ActivationLayer = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst ConnectionType_1 = require(\"../../../enums/ConnectionType\");\r\nconst ActivationNode_1 = require(\"../../Nodes/ActivationNode\");\r\nconst Layer_1 = require(\"../Layer\");\r\n/**\r\n * Activation layer\r\n */\r\nclass ActivationLayer extends Layer_1.Layer {\r\n    constructor(outputSize, options = {}) {\r\n        var _a;\r\n        super(outputSize);\r\n        const activation = (_a = options.activation) !== null && _a !== void 0 ? _a : src_1.Logistic;\r\n        for (let i = 0; i < outputSize; i++) {\r\n            this.inputNodes.add(new ActivationNode_1.ActivationNode().setActivationType(activation));\r\n        }\r\n        this.outputNodes = this.inputNodes;\r\n        this.nodes.push(...Array.from(this.inputNodes));\r\n    }\r\n    /**\r\n     * Checks if a given connection type is allowed on this layer.\r\n     *\r\n     * @param type the type to check\r\n     *\r\n     * @return Is this connection type allowed?\r\n     */\r\n    connectionTypeisAllowed(type) {\r\n        return type === ConnectionType_1.ConnectionType.ONE_TO_ONE;\r\n    }\r\n    /**\r\n     * Gets the default connection type for a incoming connection to this layer.\r\n     *\r\n     * @returns the default incoming connection\r\n     */\r\n    getDefaultIncomingConnectionType() {\r\n        return ConnectionType_1.ConnectionType.ONE_TO_ONE;\r\n    }\r\n}\r\nexports.ActivationLayer = ActivationLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DenseLayer = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst ConnectionType_1 = require(\"../../../enums/ConnectionType\");\r\nconst NodeType_1 = require(\"../../../enums/NodeType\");\r\nconst Node_1 = require(\"../../Node\");\r\nconst Layer_1 = require(\"../Layer\");\r\n/**\r\n * Dense layer\r\n */\r\nclass DenseLayer extends Layer_1.Layer {\r\n    constructor(outputSize, options = {}) {\r\n        var _a;\r\n        super(outputSize);\r\n        const activation = (_a = options.activationType) !== null && _a !== void 0 ? _a : src_1.Logistic;\r\n        for (let i = 0; i < outputSize; i++) {\r\n            this.inputNodes.add(new Node_1.Node(NodeType_1.NodeType.HIDDEN).setActivationType(activation));\r\n        }\r\n        this.outputNodes = this.inputNodes;\r\n        this.nodes.push(...Array.from(this.inputNodes));\r\n    }\r\n    /**\r\n     * Checks if a given connection type is allowed on this layer.\r\n     *\r\n     * @param type the type to check\r\n     *\r\n     * @return Is this connection type allowed?\r\n     */\r\n    connectionTypeisAllowed(type) {\r\n        return true;\r\n    }\r\n    /**\r\n     * Gets the default connection type for a incoming connection to this layer.\r\n     *\r\n     * @returns the default incoming connection\r\n     */\r\n    getDefaultIncomingConnectionType() {\r\n        return ConnectionType_1.ConnectionType.ALL_TO_ALL;\r\n    }\r\n}\r\nexports.DenseLayer = DenseLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DropoutNode = void 0;\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nconst ConstantNode_1 = require(\"./ConstantNode\");\r\n/**\r\n * Dropout node\r\n */\r\nclass DropoutNode extends ConstantNode_1.ConstantNode {\r\n    constructor(probability) {\r\n        super();\r\n        this.probability = probability;\r\n        this.droppedOut = false;\r\n    }\r\n    /**\r\n     * Actives the node.\r\n     *\r\n     * When a neuron activates, it computes its state from all its input connections and 'squashes' it using its activation function, and returns the output (activation).\r\n     *\r\n     * You can also provide the activation (a float between 0 and 1) as a parameter, which is useful for neurons in the input layer.\r\n     *\r\n     * @returns A neuron's output value\r\n     */\r\n    activate() {\r\n        if (this.incoming.size !== 1) {\r\n            throw new RangeError(\"Dropout node should have exactly one incoming connection!\");\r\n        }\r\n        const incomingConnection = Array.from(this.incoming)[0];\r\n        // https://stats.stackexchange.com/a/219240\r\n        if (Utils_1.randDouble(0, 1) < this.probability) {\r\n            // DROPOUT\r\n            this.droppedOut = true;\r\n            this.state = 0;\r\n        }\r\n        else {\r\n            this.droppedOut = false;\r\n            this.state = incomingConnection.from.activation * incomingConnection.weight * incomingConnection.gain;\r\n            this.state *= 1 / (1 - this.probability);\r\n        }\r\n        this.activation = this.squash(this.state, false) * this.mask;\r\n        // Adjust gain\r\n        this.gated.forEach(conn => conn.gain = this.activation);\r\n        return this.activation;\r\n    }\r\n    /**\r\n     * Backpropagate the error (a.k.a. learn).\r\n     *\r\n     * After an activation, you can teach the node what should have been the correct output (a.k.a. train). This is done by backpropagating. [Momentum](https://www.willamette.edu/~gorr/classes/cs449/momrate.html) adds a fraction of the previous weight update to the current one. When the gradient keeps pointing in the same direction, this will increase the size of the steps taken towards the minimum.\r\n     *\r\n     * If you combine a high learning rate with a lot of momentum, you will rush past the minimum (of the error function) with huge steps. It is therefore often necessary to reduce the global learning rate  when using a lot of momentum (m close to 1).\r\n     *\r\n     * @param target The target value (i.e. \"the value the network SHOULD have given\")\r\n     * @param options More options for propagation\r\n     */\r\n    propagate(target, options = {}) {\r\n        var _a, _b, _c;\r\n        options.momentum = (_a = options.momentum) !== null && _a !== void 0 ? _a : 0;\r\n        options.rate = (_b = options.rate) !== null && _b !== void 0 ? _b : 0.3;\r\n        options.update = (_c = options.update) !== null && _c !== void 0 ? _c : true;\r\n        const connectionsStates = Array.from(this.outgoing).map(conn => conn.to.errorResponsibility * conn.weight * conn.gain);\r\n        this.errorResponsibility = this.errorProjected = Utils_1.sum(connectionsStates) / (1 - this.probability);\r\n        if (this.incoming.size !== 1) {\r\n            throw new RangeError(\"Dropout node should have exactly one incoming connection!\");\r\n        }\r\n        const connection = Array.from(this.incoming)[0];\r\n        // calculate gradient\r\n        if (!this.droppedOut) {\r\n            let gradient = this.errorProjected * connection.eligibility;\r\n            connection.xTrace.forEach((value, key) => {\r\n                gradient += key.errorResponsibility * value;\r\n            });\r\n            if (options.update) {\r\n                connection.deltaWeightsTotal += options.rate * gradient * this.mask + options.momentum * connection.deltaWeightsPrevious;\r\n                connection.weight += connection.deltaWeightsTotal;\r\n                connection.deltaWeightsPrevious = connection.deltaWeightsTotal;\r\n                connection.deltaWeightsTotal = 0;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Create a constant node from json object.\r\n     *\r\n     * @param json the json object representing the node\r\n     *\r\n     * @returns the created node\r\n     */\r\n    fromJSON(json) {\r\n        super.fromJSON(json);\r\n        this.probability = json.probability;\r\n        return this;\r\n    }\r\n    /**\r\n     * Convert this node into a json object.\r\n     *\r\n     * @returns the json object representing this node\r\n     */\r\n    toJSON() {\r\n        return Object.assign(super.toJSON(), {\r\n            probability: this.probability\r\n        });\r\n    }\r\n}\r\nexports.DropoutNode = DropoutNode;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.DropoutLayer = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst ConnectionType_1 = require(\"../../../enums/ConnectionType\");\r\nconst DropoutNode_1 = require(\"../../Nodes/DropoutNode\");\r\nconst Layer_1 = require(\"../Layer\");\r\n/**\r\n * Dropout layer\r\n */\r\nclass DropoutLayer extends Layer_1.Layer {\r\n    constructor(outputSize, options = {}) {\r\n        var _a, _b;\r\n        super(outputSize);\r\n        const activation = (_a = options.activation) !== null && _a !== void 0 ? _a : src_1.Identitiy;\r\n        const probability = (_b = options.probability) !== null && _b !== void 0 ? _b : 0.1;\r\n        for (let i = 0; i < outputSize; i++) {\r\n            this.inputNodes.add(new DropoutNode_1.DropoutNode(probability).setActivationType(activation));\r\n        }\r\n        this.outputNodes = this.inputNodes;\r\n        this.nodes.push(...Array.from(this.inputNodes));\r\n    }\r\n    /**\r\n     * Gets the default connection type for a incoming connection to this layer.\r\n     *\r\n     * @returns the default incoming connection\r\n     */\r\n    getDefaultIncomingConnectionType() {\r\n        return ConnectionType_1.ConnectionType.ONE_TO_ONE;\r\n    }\r\n    /**\r\n     * Checks if a given connection type is allowed on this layer.\r\n     *\r\n     * @param type the type to check\r\n     *\r\n     * @return Is this connection type allowed?\r\n     */\r\n    connectionTypeisAllowed(type) {\r\n        return type === ConnectionType_1.ConnectionType.ONE_TO_ONE;\r\n    }\r\n}\r\nexports.DropoutLayer = DropoutLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PoolNode = void 0;\r\nconst NodeType_1 = require(\"../../enums/NodeType\");\r\nconst Utils_1 = require(\"../../utils/Utils\");\r\nconst ConstantNode_1 = require(\"./ConstantNode\");\r\n/**\r\n * Pool node\r\n */\r\nclass PoolNode extends ConstantNode_1.ConstantNode {\r\n    constructor(poolingType = NodeType_1.PoolNodeType.MAX_POOLING) {\r\n        super();\r\n        this.poolingType = poolingType;\r\n        this.receivingNode = null;\r\n    }\r\n    /**\r\n     * Create a constant node from json object.\r\n     *\r\n     * @param json the json object representing the node\r\n     *\r\n     * @returns the created node\r\n     */\r\n    fromJSON(json) {\r\n        super.fromJSON(json);\r\n        this.poolingType = json.poolType;\r\n        return this;\r\n    }\r\n    /**\r\n     * Actives the node.\r\n     *\r\n     * When a neuron activates, it computes its state from all its input connections and 'squashes' it using its activation function, and returns the output (activation).\r\n     *\r\n     * You can also provide the activation (a float between 0 and 1) as a parameter, which is useful for neurons in the input layer.\r\n     *\r\n     * @returns A neuron's output value\r\n     */\r\n    activate() {\r\n        const connections = Array.from(this.incoming);\r\n        const incomingStates = connections.map(conn => conn.from.activation * conn.weight * conn.gain);\r\n        if (this.poolingType === NodeType_1.PoolNodeType.MAX_POOLING) {\r\n            const index = Utils_1.maxValueIndex(incomingStates);\r\n            this.receivingNode = connections[index].from;\r\n            this.state = incomingStates[index];\r\n        }\r\n        else if (this.poolingType === NodeType_1.PoolNodeType.AVG_POOLING) {\r\n            this.state = Utils_1.avg(incomingStates);\r\n        }\r\n        else if (this.poolingType === NodeType_1.PoolNodeType.MIN_POOLING) {\r\n            const index = Utils_1.minValueIndex(incomingStates);\r\n            this.receivingNode = connections[index].from;\r\n            this.state = incomingStates[index];\r\n        }\r\n        else {\r\n            throw new ReferenceError(\"No valid pooling type! Type: \" + this.poolingType);\r\n        }\r\n        this.activation = this.squash(this.state, false) * this.mask;\r\n        if (this.poolingType === NodeType_1.PoolNodeType.AVG_POOLING) {\r\n            this.derivativeState = this.squash(this.state, true);\r\n        }\r\n        // Adjust gain\r\n        this.gated.forEach(conn => conn.gain = this.activation);\r\n        return this.activation;\r\n    }\r\n    /**\r\n     * Backpropagate the error (a.k.a. learn).\r\n     *\r\n     * After an activation, you can teach the node what should have been the correct output (a.k.a. train). This is done by backpropagating. [Momentum](https://www.willamette.edu/~gorr/classes/cs449/momrate.html) adds a fraction of the previous weight update to the current one. When the gradient keeps pointing in the same direction, this will increase the size of the steps taken towards the minimum.\r\n     *\r\n     * If you combine a high learning rate with a lot of momentum, you will rush past the minimum (of the error function) with huge steps. It is therefore often necessary to reduce the global learning rate  when using a lot of momentum (m close to 1).\r\n     *\r\n     * @param target The target value (i.e. \"the value the network SHOULD have given\")\r\n     * @param options More options for propagation\r\n     */\r\n    propagate(target, options = {}) {\r\n        var _a, _b, _c;\r\n        options.momentum = (_a = options.momentum) !== null && _a !== void 0 ? _a : 0;\r\n        options.rate = (_b = options.rate) !== null && _b !== void 0 ? _b : 0.3;\r\n        options.update = (_c = options.update) !== null && _c !== void 0 ? _c : true;\r\n        const connectionsStates = Array.from(this.outgoing).map(conn => conn.to.errorResponsibility * conn.weight * conn.gain);\r\n        this.errorResponsibility = this.errorProjected = Utils_1.sum(connectionsStates) * this.derivativeState;\r\n        if (this.poolingType === NodeType_1.PoolNodeType.AVG_POOLING) {\r\n            this.incoming.forEach(connection => {\r\n                var _a, _b;\r\n                // calculate gradient\r\n                let gradient = this.errorProjected * connection.eligibility;\r\n                connection.xTrace.forEach((value, key) => {\r\n                    gradient += key.errorResponsibility * value;\r\n                });\r\n                connection.deltaWeightsTotal += ((_a = options.rate) !== null && _a !== void 0 ? _a : 0.3) * gradient * this.mask;\r\n                if (options.update) {\r\n                    connection.deltaWeightsTotal += ((_b = options.momentum) !== null && _b !== void 0 ? _b : 0) * connection.deltaWeightsPrevious;\r\n                    connection.weight += connection.deltaWeightsTotal;\r\n                    connection.deltaWeightsPrevious = connection.deltaWeightsTotal;\r\n                    connection.deltaWeightsTotal = 0;\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            // TODO: don't think that this is correct\r\n            // Passing only the connections that were used for getting the min or max\r\n            this.incoming.forEach(conn => {\r\n                conn.weight = this.receivingNode === conn.from ? 1 : 0;\r\n                conn.gain = this.receivingNode === conn.from ? 1 : 0;\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * Convert this node into a json object.\r\n     *\r\n     * @returns the json object representing this node\r\n     */\r\n    toJSON() {\r\n        return Object.assign(super.toJSON(), {\r\n            poolType: this.poolingType\r\n        });\r\n    }\r\n}\r\nexports.PoolNode = PoolNode;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.PoolingLayer = void 0;\r\nconst ConnectionType_1 = require(\"../../../enums/ConnectionType\");\r\nconst Layer_1 = require(\"../Layer\");\r\n/**\r\n * Parent class for all pooling layers\r\n */\r\nclass PoolingLayer extends Layer_1.Layer {\r\n    constructor(outputSize) {\r\n        super(outputSize);\r\n    }\r\n    /**\r\n     * Gets the default connection type for a incoming connection to this layer.\r\n     *\r\n     * @returns the default incoming connection\r\n     */\r\n    getDefaultIncomingConnectionType() {\r\n        return ConnectionType_1.ConnectionType.POOLING;\r\n    }\r\n    /**\r\n     * Checks if a given connection type is allowed on this layer.\r\n     *\r\n     * @param type the type to check\r\n     *\r\n     * @return Is this connection type allowed?\r\n     */\r\n    connectionTypeisAllowed(type) {\r\n        return true;\r\n    }\r\n}\r\nexports.PoolingLayer = PoolingLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.AvgPooling1DLayer = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst NodeType_1 = require(\"../../../enums/NodeType\");\r\nconst PoolNode_1 = require(\"../../Nodes/PoolNode\");\r\nconst PoolingLayer_1 = require(\"./PoolingLayer\");\r\n/**\r\n * Average pooling layer 1D\r\n */\r\nclass AvgPooling1DLayer extends PoolingLayer_1.PoolingLayer {\r\n    constructor(outputSize, options = {}) {\r\n        var _a;\r\n        super(outputSize);\r\n        const activationType = (_a = options.activation) !== null && _a !== void 0 ? _a : src_1.Identitiy;\r\n        for (let i = 0; i < outputSize; i++) {\r\n            this.inputNodes.add(new PoolNode_1.PoolNode(NodeType_1.PoolNodeType.AVG_POOLING).setActivationType(activationType));\r\n        }\r\n        this.outputNodes = this.inputNodes;\r\n        this.nodes.push(...Array.from(this.inputNodes));\r\n    }\r\n}\r\nexports.AvgPooling1DLayer = AvgPooling1DLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GlobalAvgPooling1DLayer = void 0;\r\nconst AvgPooling1DLayer_1 = require(\"./AvgPooling1DLayer\");\r\n/**\r\n * Global average pooling layer 1D\r\n */\r\nclass GlobalAvgPooling1DLayer extends AvgPooling1DLayer_1.AvgPooling1DLayer {\r\n    constructor(outputSize, options = {}) {\r\n        super(1, options);\r\n    }\r\n}\r\nexports.GlobalAvgPooling1DLayer = GlobalAvgPooling1DLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MaxPooling1DLayer = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst NodeType_1 = require(\"../../../enums/NodeType\");\r\nconst PoolNode_1 = require(\"../../Nodes/PoolNode\");\r\nconst PoolingLayer_1 = require(\"./PoolingLayer\");\r\n/**\r\n * Maximum pooling layer 1D\r\n */\r\nclass MaxPooling1DLayer extends PoolingLayer_1.PoolingLayer {\r\n    constructor(outputSize, options = {}) {\r\n        var _a;\r\n        super(outputSize);\r\n        const activationType = (_a = options.activation) !== null && _a !== void 0 ? _a : src_1.Identitiy;\r\n        for (let i = 0; i < outputSize; i++) {\r\n            this.inputNodes.add(new PoolNode_1.PoolNode(NodeType_1.PoolNodeType.MAX_POOLING).setActivationType(activationType));\r\n        }\r\n        this.outputNodes = this.inputNodes;\r\n        this.nodes.push(...Array.from(this.inputNodes));\r\n    }\r\n}\r\nexports.MaxPooling1DLayer = MaxPooling1DLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GlobalMaxPooling1DLayer = void 0;\r\nconst MaxPooling1DLayer_1 = require(\"./MaxPooling1DLayer\");\r\n/**\r\n * Global maximum pooling layer 1D\r\n */\r\nclass GlobalMaxPooling1DLayer extends MaxPooling1DLayer_1.MaxPooling1DLayer {\r\n    constructor(outputSize, options = {}) {\r\n        super(1, options);\r\n    }\r\n}\r\nexports.GlobalMaxPooling1DLayer = GlobalMaxPooling1DLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MinPooling1DLayer = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst NodeType_1 = require(\"../../../enums/NodeType\");\r\nconst PoolNode_1 = require(\"../../Nodes/PoolNode\");\r\nconst PoolingLayer_1 = require(\"./PoolingLayer\");\r\n/**\r\n * Minimum pooling layer 1D\r\n */\r\nclass MinPooling1DLayer extends PoolingLayer_1.PoolingLayer {\r\n    constructor(outputSize, options = {}) {\r\n        var _a;\r\n        super(outputSize);\r\n        const activationType = (_a = options.activation) !== null && _a !== void 0 ? _a : src_1.Identitiy;\r\n        for (let i = 0; i < outputSize; i++) {\r\n            this.inputNodes.add(new PoolNode_1.PoolNode(NodeType_1.PoolNodeType.MIN_POOLING).setActivationType(activationType));\r\n        }\r\n        this.outputNodes = this.inputNodes;\r\n        this.nodes.push(...Array.from(this.inputNodes));\r\n    }\r\n}\r\nexports.MinPooling1DLayer = MinPooling1DLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GlobalMinPooling1DLayer = void 0;\r\nconst MinPooling1DLayer_1 = require(\"./MinPooling1DLayer\");\r\n/**\r\n * Global minimum pooling layer 1D\r\n */\r\nclass GlobalMinPooling1DLayer extends MinPooling1DLayer_1.MinPooling1DLayer {\r\n    constructor(outputSize, options = {}) {\r\n        super(1, options);\r\n    }\r\n}\r\nexports.GlobalMinPooling1DLayer = GlobalMinPooling1DLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.GRULayer = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst ConnectionType_1 = require(\"../../../enums/ConnectionType\");\r\nconst GatingType_1 = require(\"../../../enums/GatingType\");\r\nconst NodeType_1 = require(\"../../../enums/NodeType\");\r\nconst Node_1 = require(\"../../Node\");\r\nconst Layer_1 = require(\"../Layer\");\r\n/**\r\n * GRU layer\r\n */\r\nclass GRULayer extends Layer_1.Layer {\r\n    constructor(outputSize, options = {}) {\r\n        super(outputSize);\r\n        const updateGate = [];\r\n        const inverseUpdateGate = [];\r\n        const resetGate = [];\r\n        const memoryCell = [];\r\n        const previousOutput = [];\r\n        for (let i = 0; i < outputSize; i++) {\r\n            this.inputNodes.add(new Node_1.Node(NodeType_1.NodeType.HIDDEN));\r\n            updateGate.push(new Node_1.Node(NodeType_1.NodeType.HIDDEN).setBias(1));\r\n            inverseUpdateGate.push(new Node_1.Node(NodeType_1.NodeType.HIDDEN).setBias(0).setActivationType(src_1.Logistic));\r\n            resetGate.push(new Node_1.Node(NodeType_1.NodeType.HIDDEN).setBias(0));\r\n            memoryCell.push(new Node_1.Node(NodeType_1.NodeType.HIDDEN).setActivationType(src_1.TANH));\r\n            previousOutput.push(new Node_1.Node(NodeType_1.NodeType.HIDDEN).setBias(0).setActivationType(src_1.Logistic));\r\n            this.outputNodes.add(new Node_1.Node(NodeType_1.NodeType.HIDDEN));\r\n        }\r\n        this.connections.push(...Layer_1.Layer.connect(this.inputNodes, updateGate, ConnectionType_1.ConnectionType.ALL_TO_ALL));\r\n        this.connections.push(...Layer_1.Layer.connect(this.inputNodes, resetGate, ConnectionType_1.ConnectionType.ALL_TO_ALL));\r\n        this.connections.push(...Layer_1.Layer.connect(this.inputNodes, memoryCell, ConnectionType_1.ConnectionType.ALL_TO_ALL));\r\n        this.connections.push(...Layer_1.Layer.connect(previousOutput, updateGate, ConnectionType_1.ConnectionType.ALL_TO_ALL));\r\n        this.connections.push(...Layer_1.Layer.connect(updateGate, inverseUpdateGate, ConnectionType_1.ConnectionType.ONE_TO_ONE, 1));\r\n        this.connections.push(...Layer_1.Layer.connect(previousOutput, resetGate, ConnectionType_1.ConnectionType.ALL_TO_ALL));\r\n        const reset = Layer_1.Layer.connect(previousOutput, memoryCell, ConnectionType_1.ConnectionType.ALL_TO_ALL);\r\n        this.connections.push(...reset);\r\n        this.gates.push(...Layer_1.Layer.gate(resetGate, reset, GatingType_1.GatingType.OUTPUT));\r\n        const update = Layer_1.Layer.connect(previousOutput, this.outputNodes, ConnectionType_1.ConnectionType.ALL_TO_ALL);\r\n        const inverseUpdate = Layer_1.Layer.connect(memoryCell, this.outputNodes, ConnectionType_1.ConnectionType.ALL_TO_ALL);\r\n        this.connections.push(...update);\r\n        this.connections.push(...inverseUpdate);\r\n        this.gates.push(...Layer_1.Layer.gate(updateGate, update, GatingType_1.GatingType.OUTPUT));\r\n        this.gates.push(...Layer_1.Layer.gate(inverseUpdateGate, inverseUpdate, GatingType_1.GatingType.OUTPUT));\r\n        this.connections.push(...Layer_1.Layer.connect(this.outputNodes, previousOutput, ConnectionType_1.ConnectionType.ONE_TO_ONE, 1));\r\n        this.nodes.push(...Array.from(this.inputNodes));\r\n        this.nodes.push(...updateGate);\r\n        this.nodes.push(...inverseUpdateGate);\r\n        this.nodes.push(...resetGate);\r\n        this.nodes.push(...memoryCell);\r\n        this.nodes.push(...Array.from(this.outputNodes));\r\n        this.nodes.push(...previousOutput);\r\n        this.outputNodes.forEach(node => { var _a; return node.squash = (_a = options.activation) !== null && _a !== void 0 ? _a : src_1.Logistic; });\r\n    }\r\n    /**\r\n     * Checks if a given connection type is allowed on this layer.\r\n     *\r\n     * @param type the type to check\r\n     *\r\n     * @return Is this connection type allowed?\r\n     */\r\n    connectionTypeisAllowed(type) {\r\n        return true;\r\n    }\r\n    /**\r\n     * Gets the default connection type for a incoming connection to this layer.\r\n     *\r\n     * @returns the default incoming connection\r\n     */\r\n    getDefaultIncomingConnectionType() {\r\n        return ConnectionType_1.ConnectionType.ALL_TO_ALL;\r\n    }\r\n}\r\nexports.GRULayer = GRULayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.HopfieldLayer = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst ConnectionType_1 = require(\"../../../enums/ConnectionType\");\r\nconst NodeType_1 = require(\"../../../enums/NodeType\");\r\nconst Node_1 = require(\"../../Node\");\r\nconst Layer_1 = require(\"../Layer\");\r\n/**\r\n * Hopfield layer\r\n */\r\nclass HopfieldLayer extends Layer_1.Layer {\r\n    constructor(outputSize) {\r\n        super(outputSize);\r\n        for (let i = 0; i < outputSize; i++) {\r\n            this.inputNodes.add(new Node_1.Node(NodeType_1.NodeType.HIDDEN));\r\n            this.outputNodes.add(new Node_1.Node(NodeType_1.NodeType.HIDDEN).setActivationType(src_1.BinaryStep));\r\n        }\r\n        this.connections.push(...Layer_1.Layer.connect(this.inputNodes, this.outputNodes, ConnectionType_1.ConnectionType.ALL_TO_ALL));\r\n        this.connections.push(...Layer_1.Layer.connect(this.outputNodes, this.inputNodes, ConnectionType_1.ConnectionType.ALL_TO_ALL));\r\n        this.nodes.push(...Array.from(this.inputNodes));\r\n        this.nodes.push(...Array.from(this.outputNodes));\r\n    }\r\n    /**\r\n     * Checks if a given connection type is allowed on this layer.\r\n     *\r\n     * @param type the type to check\r\n     *\r\n     * @return Is this connection type allowed?\r\n     */\r\n    connectionTypeisAllowed(type) {\r\n        return true;\r\n    }\r\n    /**\r\n     * Gets the default connection type for a incoming connection to this layer.\r\n     *\r\n     * @returns the default incoming connection\r\n     */\r\n    getDefaultIncomingConnectionType() {\r\n        return ConnectionType_1.ConnectionType.ALL_TO_ALL;\r\n    }\r\n}\r\nexports.HopfieldLayer = HopfieldLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.LSTMLayer = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst ConnectionType_1 = require(\"../../../enums/ConnectionType\");\r\nconst GatingType_1 = require(\"../../../enums/GatingType\");\r\nconst NodeType_1 = require(\"../../../enums/NodeType\");\r\nconst Node_1 = require(\"../../Node\");\r\nconst Layer_1 = require(\"../Layer\");\r\n/**\r\n * LSTM layer\r\n */\r\nclass LSTMLayer extends Layer_1.Layer {\r\n    constructor(outputSize, options = {}) {\r\n        super(outputSize);\r\n        const inputGate = [];\r\n        const forgetGate = [];\r\n        const memoryCell = [];\r\n        const outputGate = [];\r\n        for (let i = 0; i < outputSize; i++) {\r\n            this.inputNodes.add(new Node_1.Node(NodeType_1.NodeType.HIDDEN));\r\n            inputGate.push(new Node_1.Node(NodeType_1.NodeType.HIDDEN).setBias(1));\r\n            forgetGate.push(new Node_1.Node(NodeType_1.NodeType.HIDDEN).setBias(1).setActivationType(src_1.Logistic));\r\n            memoryCell.push(new Node_1.Node(NodeType_1.NodeType.HIDDEN));\r\n            outputGate.push(new Node_1.Node(NodeType_1.NodeType.HIDDEN).setBias(1));\r\n            this.outputNodes.add(new Node_1.Node(NodeType_1.NodeType.HIDDEN));\r\n        }\r\n        this.connections.push(...Layer_1.Layer.connect(memoryCell, inputGate, ConnectionType_1.ConnectionType.ALL_TO_ALL));\r\n        this.connections.push(...Layer_1.Layer.connect(memoryCell, forgetGate, ConnectionType_1.ConnectionType.ALL_TO_ALL));\r\n        this.connections.push(...Layer_1.Layer.connect(memoryCell, outputGate, ConnectionType_1.ConnectionType.ALL_TO_ALL));\r\n        const forgetGateConnections = Layer_1.Layer.connect(memoryCell, memoryCell, ConnectionType_1.ConnectionType.ONE_TO_ONE);\r\n        const outputGateConnections = Layer_1.Layer.connect(memoryCell, this.outputNodes, ConnectionType_1.ConnectionType.ALL_TO_ALL);\r\n        this.connections.push(...forgetGateConnections);\r\n        this.connections.push(...outputGateConnections);\r\n        this.connections.push(...Layer_1.Layer.connect(this.inputNodes, memoryCell, ConnectionType_1.ConnectionType.ALL_TO_ALL));\r\n        this.connections.push(...Layer_1.Layer.connect(this.inputNodes, outputGate, ConnectionType_1.ConnectionType.ALL_TO_ALL));\r\n        this.connections.push(...Layer_1.Layer.connect(this.inputNodes, forgetGate, ConnectionType_1.ConnectionType.ALL_TO_ALL));\r\n        const inputGateConnections = Layer_1.Layer.connect(this.inputNodes, inputGate, ConnectionType_1.ConnectionType.ALL_TO_ALL);\r\n        this.connections.push(...inputGateConnections);\r\n        this.gates.push(...Layer_1.Layer.gate(forgetGate, forgetGateConnections, GatingType_1.GatingType.SELF));\r\n        this.gates.push(...Layer_1.Layer.gate(outputGate, outputGateConnections, GatingType_1.GatingType.OUTPUT));\r\n        this.gates.push(...Layer_1.Layer.gate(inputGate, inputGateConnections, GatingType_1.GatingType.INPUT));\r\n        this.nodes.push(...Array.from(this.inputNodes));\r\n        this.nodes.push(...inputGate);\r\n        this.nodes.push(...forgetGate);\r\n        this.nodes.push(...memoryCell);\r\n        this.nodes.push(...outputGate);\r\n        this.nodes.push(...Array.from(this.outputNodes));\r\n        this.outputNodes.forEach(node => { var _a; return node.squash = (_a = options.activation) !== null && _a !== void 0 ? _a : src_1.TANH; });\r\n    }\r\n    /**\r\n     * Checks if a given connection type is allowed on this layer.\r\n     *\r\n     * @param type the type to check\r\n     *\r\n     * @return Is this connection type allowed?\r\n     */\r\n    connectionTypeisAllowed(type) {\r\n        return true;\r\n    }\r\n    /**\r\n     * Gets the default connection type for a incoming connection to this layer.\r\n     *\r\n     * @returns the default incoming connection\r\n     */\r\n    getDefaultIncomingConnectionType() {\r\n        return ConnectionType_1.ConnectionType.ALL_TO_ALL;\r\n    }\r\n}\r\nexports.LSTMLayer = LSTMLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.MemoryLayer = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst ConnectionType_1 = require(\"../../../enums/ConnectionType\");\r\nconst NodeType_1 = require(\"../../../enums/NodeType\");\r\nconst Node_1 = require(\"../../Node\");\r\nconst Layer_1 = require(\"../Layer\");\r\n/**\r\n * Memory layer\r\n */\r\nclass MemoryLayer extends Layer_1.Layer {\r\n    constructor(outputSize, options = {}) {\r\n        var _a;\r\n        super(outputSize);\r\n        for (let i = 0; i < outputSize; i++) {\r\n            this.inputNodes.add(new Node_1.Node(NodeType_1.NodeType.HIDDEN));\r\n        }\r\n        let prevNodes = Array.from(this.inputNodes);\r\n        const nodes = [];\r\n        for (let i = 0; i < ((_a = options.memorySize) !== null && _a !== void 0 ? _a : 1); i++) {\r\n            const block = [];\r\n            for (let j = 0; j < outputSize; j++) {\r\n                const node = new Node_1.Node(NodeType_1.NodeType.HIDDEN);\r\n                node.squash = src_1.Identitiy;\r\n                node.bias = 0;\r\n                block.push(node);\r\n            }\r\n            this.connections.push(...Layer_1.Layer.connect(prevNodes, block, ConnectionType_1.ConnectionType.ONE_TO_ONE));\r\n            nodes.push(...block);\r\n            prevNodes = block;\r\n        }\r\n        this.nodes.push(...Array.from(this.inputNodes));\r\n        this.nodes.push(...(nodes.reverse()));\r\n        prevNodes.forEach(node => this.outputNodes.add(node));\r\n        this.outputNodes.forEach(node => { var _a; return node.squash = (_a = options.activation) !== null && _a !== void 0 ? _a : src_1.Logistic; });\r\n    }\r\n    /**\r\n     * Checks if a given connection type is allowed on this layer.\r\n     *\r\n     * @param type the type to check\r\n     *\r\n     * @return Is this connection type allowed?\r\n     */\r\n    connectionTypeisAllowed(type) {\r\n        return true;\r\n    }\r\n    /**\r\n     * Gets the default connection type for a incoming connection to this layer.\r\n     *\r\n     * @returns the default incoming connection\r\n     */\r\n    getDefaultIncomingConnectionType() {\r\n        return ConnectionType_1.ConnectionType.ALL_TO_ALL;\r\n    }\r\n}\r\nexports.MemoryLayer = MemoryLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.RNNLayer = void 0;\r\nconst src_1 = require(\"activations/build/src\");\r\nconst ConnectionType_1 = require(\"../../../enums/ConnectionType\");\r\nconst NodeType_1 = require(\"../../../enums/NodeType\");\r\nconst Node_1 = require(\"../../Node\");\r\nconst Layer_1 = require(\"../Layer\");\r\n/**\r\n * RNN layer\r\n */\r\nclass RNNLayer extends Layer_1.Layer {\r\n    constructor(outputSize, options = {}) {\r\n        var _a;\r\n        super(outputSize);\r\n        for (let i = 0; i < outputSize; i++) {\r\n            this.inputNodes.add(new Node_1.Node(NodeType_1.NodeType.HIDDEN).setActivationType((_a = options.activation) !== null && _a !== void 0 ? _a : src_1.Logistic));\r\n        }\r\n        this.outputNodes = this.inputNodes;\r\n        this.nodes.push(...Array.from(this.inputNodes));\r\n        // Adding self connections\r\n        this.connections.push(...Layer_1.Layer.connect(this.nodes, this.nodes, ConnectionType_1.ConnectionType.ONE_TO_ONE));\r\n    }\r\n    /**\r\n     * Checks if a given connection type is allowed on this layer.\r\n     *\r\n     * @param type the type to check\r\n     *\r\n     * @return Is this connection type allowed?\r\n     */\r\n    connectionTypeisAllowed(type) {\r\n        return true;\r\n    }\r\n    /**\r\n     * Gets the default connection type for a incoming connection to this layer.\r\n     *\r\n     * @returns the default incoming connection\r\n     */\r\n    getDefaultIncomingConnectionType() {\r\n        return ConnectionType_1.ConnectionType.ALL_TO_ALL;\r\n    }\r\n}\r\nexports.RNNLayer = RNNLayer;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.InverseRate = exports.ExponentialRate = exports.StepRate = exports.FixedRate = exports.Rate = void 0;\r\n/**\r\n * Built-in learning rate policies, which allow for a dynamic learning rate during neural network training.\r\n *\r\n * @see [Learning rates and how-to improve performance](https://towardsdatascience.com/understanding-learning-rates-and-how-it-improves-performance-in-deep-learning-d0d4059c1c10)\r\n * @see [Learning rate policy](https://stackoverflow.com/questions/30033096/what-is-lr-policy-in-caffe/30045244)\r\n *\r\n */\r\nclass Rate {\r\n    /**\r\n     * Constructs a rate policy\r\n     * @param baseRate the rate at first iteration\r\n     */\r\n    constructor(baseRate) {\r\n        this.baseRate = baseRate;\r\n    }\r\n}\r\nexports.Rate = Rate;\r\n/**\r\n * Fixed Learning Rate\r\n *\r\n * Default rate policy. Using this will make learning rate static (no change). Useful as a way to update a previous rate policy.\r\n */\r\nclass FixedRate extends Rate {\r\n    /**\r\n     * Calculates the current training rate.\r\n     *\r\n     * @param iteration count\r\n     * @returns the current training rate\r\n     */\r\n    calc(iteration) {\r\n        return this.baseRate;\r\n    }\r\n}\r\nexports.FixedRate = FixedRate;\r\n/**\r\n * Step Learning Rate\r\n *\r\n * The learning rate will decrease (i.e. 'step down') every `stepSize` iterations.\r\n */\r\nclass StepRate extends Rate {\r\n    /**\r\n     * Constructs a step rate policy.\r\n     *\r\n     * @param baseRate the rate at first iteration\r\n     * @param gamma=0.9 Learning rate retention per step; - _0 < `gamma` < 1_ - _large `gamma` CAN cause networks to never converge, low `gamma` CAN cause networks to converge too quickly_\r\n     * @param stepSize=100 Learning rate is updated every `step_size` iterations\r\n     */\r\n    constructor(baseRate, gamma = 0.9, stepSize = 100) {\r\n        super(baseRate);\r\n        this.gamma = gamma;\r\n        this.stepSize = stepSize;\r\n    }\r\n    /**\r\n     * Calculates the current training rate.\r\n     *\r\n     * @param iteration count\r\n     * @returns the current training rate\r\n     */\r\n    calc(iteration) {\r\n        return this.baseRate * Math.pow(this.gamma, Math.floor(iteration / this.stepSize));\r\n    }\r\n}\r\nexports.StepRate = StepRate;\r\n/**\r\n * Exponential Learning Rate\r\n *\r\n * The learning rate will exponentially decrease.\r\n *\r\n * The rate at `iteration` is calculated as: `rate = base_rate * Math.pow(gamma, iteration)`\r\n */\r\nclass ExponentialRate extends Rate {\r\n    /**\r\n     * Constructs a step rate policy.\r\n     *\r\n     * @param baseRate the rate at first iteration\r\n     * @param gamma=0.9 Learning rate retention per step; - _0 < `gamma` < 1_ - _large `gamma` CAN cause networks to never converge, low `gamma` CAN cause networks to converge too quickly_\r\n     */\r\n    constructor(baseRate, gamma = 0.999) {\r\n        super(baseRate);\r\n        this.gamma = gamma;\r\n    }\r\n    /**\r\n     * Calculates the current training rate.\r\n     *\r\n     * @param iteration count\r\n     * @returns the current training rate\r\n     */\r\n    calc(iteration) {\r\n        return this.baseRate * Math.pow(this.gamma, iteration);\r\n    }\r\n}\r\nexports.ExponentialRate = ExponentialRate;\r\n/**\r\n * Inverse Exponential Learning Rate\r\n *\r\n * The learning rate will exponentially decrease.\r\n *\r\n * The rate at `iteration` is calculated as: `rate = baseRate * Math.pow(1 + gamma * iteration, -power)`\r\n */\r\nclass InverseRate extends Rate {\r\n    /**\r\n     * Constructs a step rate policy.\r\n     *\r\n     * @param baseRate the rate at first iteration\r\n     * @param gamma=0.001 Learning rate decay per iteration; - _0 < `gamma` < 1_ - _large `gamma` CAN cause networks to converge too quickly and stop learning, low `gamma` CAN cause networks to converge to learn VERY slowly_\r\n     * @param power=2 Decay rate per iteration - _0 < `power`_ - _large `power` CAN cause networks to stop learning quickly, low `power` CAN cause networks to learn VERY slowly_\r\n     */\r\n    constructor(baseRate, gamma = 0.001, power = 2) {\r\n        super(baseRate);\r\n        this.gamma = gamma;\r\n        this.power = power;\r\n    }\r\n    /**\r\n     * Calculates the current training rate.\r\n     *\r\n     * @param iteration count\r\n     * @returns the current training rate\r\n     */\r\n    calc(iteration) {\r\n        return this.baseRate * Math.pow((1 + this.gamma * iteration), -this.power);\r\n    }\r\n}\r\nexports.InverseRate = InverseRate;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.TrainOptions = void 0;\r\nconst Loss_1 = require(\"../methods/Loss\");\r\nconst Rate_1 = require(\"../methods/Rate\");\r\n/**\r\n * Options used to train network\r\n */\r\nclass TrainOptions {\r\n    constructor(dataset) {\r\n        this._dataset = dataset;\r\n        this._iterations = -1;\r\n        this._error = -1;\r\n        this._loss = Loss_1.MSELoss;\r\n        this._dropout = 0;\r\n        this._momentum = 0;\r\n        this._batchSize = this.dataset.length;\r\n        this._rate = new Rate_1.FixedRate(0.3);\r\n        this._log = -1;\r\n        this._crossValidateTestSize = -1;\r\n        this._shuffle = false;\r\n        this._clear = false;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get dataset() {\r\n        return this._dataset;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set dataset(value) {\r\n        this._dataset = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get shuffle() {\r\n        return this._shuffle;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set shuffle(value) {\r\n        this._shuffle = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get clear() {\r\n        return this._clear;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set clear(value) {\r\n        this._clear = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get schedule() {\r\n        return this._schedule;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set schedule(value) {\r\n        this._schedule = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get crossValidateTestSize() {\r\n        return this._crossValidateTestSize;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set crossValidateTestSize(value) {\r\n        this._crossValidateTestSize = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get rate() {\r\n        return this._rate;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set rate(value) {\r\n        this._rate = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get loss() {\r\n        return this._loss;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set loss(value) {\r\n        this._loss = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get iterations() {\r\n        return this._iterations;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set iterations(value) {\r\n        this._iterations = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get error() {\r\n        return this._error;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set error(value) {\r\n        this._error = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get momentum() {\r\n        return this._momentum;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set momentum(value) {\r\n        this._momentum = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get dropout() {\r\n        return this._dropout;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set dropout(value) {\r\n        this._dropout = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get log() {\r\n        return this._log;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set log(value) {\r\n        this._log = value;\r\n    }\r\n    /**\r\n     * Getter\r\n     */\r\n    get batchSize() {\r\n        return this._batchSize;\r\n    }\r\n    /**\r\n     * Setter\r\n     */\r\n    set batchSize(value) {\r\n        this._batchSize = value;\r\n    }\r\n}\r\nexports.TrainOptions = TrainOptions;\r\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\nexports.generateGaussian = exports.avg = exports.sum = exports.min = exports.minValueIndex = exports.maxValueIndex = exports.max = exports.shuffle = exports.removeFromArray = exports.randBoolean = exports.randDouble = exports.randInt = exports.pickRandom = exports.TournamentSelection = exports.PowerSelection = exports.FitnessProportionateSelection = exports.Selection = exports.InverseRate = exports.ExponentialRate = exports.StepRate = exports.FixedRate = exports.Rate = exports.SwapNodesMutation = exports.SubBackConnectionMutation = exports.AddBackConnectionMutation = exports.SubSelfConnectionMutation = exports.AddSelfConnectionMutation = exports.SubGateMutation = exports.AddGateMutation = exports.ModActivationMutation = exports.ModBiasMutation = exports.ModWeightMutation = exports.SubConnectionMutation = exports.AddConnectionMutation = exports.SubNodeMutation = exports.AddNodeMutation = exports.Mutation = exports.ONLY_STRUCTURE = exports.NO_STRUCTURE_MUTATIONS = exports.FEEDFORWARD_MUTATIONS = exports.ALL_MUTATIONS = exports.HINGELoss = exports.MSLELoss = exports.WAPELoss = exports.MAPELoss = exports.MAELoss = exports.BinaryLoss = exports.MBELoss = exports.MSELoss = exports.ALL_LOSSES = exports.TrainOptions = exports.EvolveOptions = exports.NoiseNodeType = exports.PoolNodeType = exports.NodeType = exports.GatingType = exports.ConnectionType = exports.Node = exports.Species = exports.Network = exports.Connection = exports.Architect = exports.PoolNode = exports.NoiseNode = exports.DropoutNode = exports.ConstantNode = exports.Layer = exports.MemoryLayer = exports.LSTMLayer = exports.GRULayer = exports.RNNLayer = exports.HopfieldLayer = exports.ActivationLayer = exports.PoolingLayer = exports.GlobalMaxPooling1DLayer = exports.GlobalMinPooling1DLayer = exports.GlobalAvgPooling1DLayer = exports.MaxPooling1DLayer = exports.MinPooling1DLayer = exports.AvgPooling1DLayer = exports.NoiseLayer = exports.OutputLayer = exports.InputLayer = exports.DropoutLayer = exports.DenseLayer = void 0;\r\nconst Architect_1 = require(\"../src/architecture/Architect\");\r\nObject.defineProperty(exports, \"Architect\", { enumerable: true, get: function () { return Architect_1.Architect; } });\r\nconst Connection_1 = require(\"../src/architecture/Connection\");\r\nObject.defineProperty(exports, \"Connection\", { enumerable: true, get: function () { return Connection_1.Connection; } });\r\nconst ActivationLayer_1 = require(\"../src/architecture/Layers/CoreLayers/ActivationLayer\");\r\nObject.defineProperty(exports, \"ActivationLayer\", { enumerable: true, get: function () { return ActivationLayer_1.ActivationLayer; } });\r\nconst DenseLayer_1 = require(\"../src/architecture/Layers/CoreLayers/DenseLayer\");\r\nObject.defineProperty(exports, \"DenseLayer\", { enumerable: true, get: function () { return DenseLayer_1.DenseLayer; } });\r\nconst DropoutLayer_1 = require(\"../src/architecture/Layers/CoreLayers/DropoutLayer\");\r\nObject.defineProperty(exports, \"DropoutLayer\", { enumerable: true, get: function () { return DropoutLayer_1.DropoutLayer; } });\r\nconst InputLayer_1 = require(\"../src/architecture/Layers/CoreLayers/InputLayer\");\r\nObject.defineProperty(exports, \"InputLayer\", { enumerable: true, get: function () { return InputLayer_1.InputLayer; } });\r\nconst OutputLayer_1 = require(\"../src/architecture/Layers/CoreLayers/OutputLayer\");\r\nObject.defineProperty(exports, \"OutputLayer\", { enumerable: true, get: function () { return OutputLayer_1.OutputLayer; } });\r\nconst Layer_1 = require(\"../src/architecture/Layers/Layer\");\r\nObject.defineProperty(exports, \"Layer\", { enumerable: true, get: function () { return Layer_1.Layer; } });\r\nconst NoiseLayer_1 = require(\"../src/architecture/Layers/NoiseLayers/NoiseLayer\");\r\nObject.defineProperty(exports, \"NoiseLayer\", { enumerable: true, get: function () { return NoiseLayer_1.NoiseLayer; } });\r\nconst AvgPooling1DLayer_1 = require(\"../src/architecture/Layers/PoolingLayers/AvgPooling1DLayer\");\r\nObject.defineProperty(exports, \"AvgPooling1DLayer\", { enumerable: true, get: function () { return AvgPooling1DLayer_1.AvgPooling1DLayer; } });\r\nconst GlobalAvgPooling1DLayer_1 = require(\"../src/architecture/Layers/PoolingLayers/GlobalAvgPooling1DLayer\");\r\nObject.defineProperty(exports, \"GlobalAvgPooling1DLayer\", { enumerable: true, get: function () { return GlobalAvgPooling1DLayer_1.GlobalAvgPooling1DLayer; } });\r\nconst GlobalMaxPooling1DLayer_1 = require(\"../src/architecture/Layers/PoolingLayers/GlobalMaxPooling1DLayer\");\r\nObject.defineProperty(exports, \"GlobalMaxPooling1DLayer\", { enumerable: true, get: function () { return GlobalMaxPooling1DLayer_1.GlobalMaxPooling1DLayer; } });\r\nconst GlobalMinPooling1DLayer_1 = require(\"../src/architecture/Layers/PoolingLayers/GlobalMinPooling1DLayer\");\r\nObject.defineProperty(exports, \"GlobalMinPooling1DLayer\", { enumerable: true, get: function () { return GlobalMinPooling1DLayer_1.GlobalMinPooling1DLayer; } });\r\nconst MaxPooling1DLayer_1 = require(\"../src/architecture/Layers/PoolingLayers/MaxPooling1DLayer\");\r\nObject.defineProperty(exports, \"MaxPooling1DLayer\", { enumerable: true, get: function () { return MaxPooling1DLayer_1.MaxPooling1DLayer; } });\r\nconst MinPooling1DLayer_1 = require(\"../src/architecture/Layers/PoolingLayers/MinPooling1DLayer\");\r\nObject.defineProperty(exports, \"MinPooling1DLayer\", { enumerable: true, get: function () { return MinPooling1DLayer_1.MinPooling1DLayer; } });\r\nconst PoolingLayer_1 = require(\"../src/architecture/Layers/PoolingLayers/PoolingLayer\");\r\nObject.defineProperty(exports, \"PoolingLayer\", { enumerable: true, get: function () { return PoolingLayer_1.PoolingLayer; } });\r\nconst GRULayer_1 = require(\"../src/architecture/Layers/RecurrentLayers/GRULayer\");\r\nObject.defineProperty(exports, \"GRULayer\", { enumerable: true, get: function () { return GRULayer_1.GRULayer; } });\r\nconst HopfieldLayer_1 = require(\"../src/architecture/Layers/RecurrentLayers/HopfieldLayer\");\r\nObject.defineProperty(exports, \"HopfieldLayer\", { enumerable: true, get: function () { return HopfieldLayer_1.HopfieldLayer; } });\r\nconst LSTMLayer_1 = require(\"../src/architecture/Layers/RecurrentLayers/LSTMLayer\");\r\nObject.defineProperty(exports, \"LSTMLayer\", { enumerable: true, get: function () { return LSTMLayer_1.LSTMLayer; } });\r\nconst MemoryLayer_1 = require(\"../src/architecture/Layers/RecurrentLayers/MemoryLayer\");\r\nObject.defineProperty(exports, \"MemoryLayer\", { enumerable: true, get: function () { return MemoryLayer_1.MemoryLayer; } });\r\nconst RNNLayer_1 = require(\"../src/architecture/Layers/RecurrentLayers/RNNLayer\");\r\nObject.defineProperty(exports, \"RNNLayer\", { enumerable: true, get: function () { return RNNLayer_1.RNNLayer; } });\r\nconst Network_1 = require(\"../src/architecture/Network\");\r\nObject.defineProperty(exports, \"Network\", { enumerable: true, get: function () { return Network_1.Network; } });\r\nconst Node_1 = require(\"../src/architecture/Node\");\r\nObject.defineProperty(exports, \"Node\", { enumerable: true, get: function () { return Node_1.Node; } });\r\nconst ConstantNode_1 = require(\"../src/architecture/Nodes/ConstantNode\");\r\nObject.defineProperty(exports, \"ConstantNode\", { enumerable: true, get: function () { return ConstantNode_1.ConstantNode; } });\r\nconst DropoutNode_1 = require(\"../src/architecture/Nodes/DropoutNode\");\r\nObject.defineProperty(exports, \"DropoutNode\", { enumerable: true, get: function () { return DropoutNode_1.DropoutNode; } });\r\nconst NoiseNode_1 = require(\"../src/architecture/Nodes/NoiseNode\");\r\nObject.defineProperty(exports, \"NoiseNode\", { enumerable: true, get: function () { return NoiseNode_1.NoiseNode; } });\r\nconst PoolNode_1 = require(\"../src/architecture/Nodes/PoolNode\");\r\nObject.defineProperty(exports, \"PoolNode\", { enumerable: true, get: function () { return PoolNode_1.PoolNode; } });\r\nconst Species_1 = require(\"../src/architecture/Species\");\r\nObject.defineProperty(exports, \"Species\", { enumerable: true, get: function () { return Species_1.Species; } });\r\nconst ConnectionType_1 = require(\"../src/enums/ConnectionType\");\r\nObject.defineProperty(exports, \"ConnectionType\", { enumerable: true, get: function () { return ConnectionType_1.ConnectionType; } });\r\nconst GatingType_1 = require(\"../src/enums/GatingType\");\r\nObject.defineProperty(exports, \"GatingType\", { enumerable: true, get: function () { return GatingType_1.GatingType; } });\r\nconst NodeType_1 = require(\"../src/enums/NodeType\");\r\nObject.defineProperty(exports, \"NodeType\", { enumerable: true, get: function () { return NodeType_1.NodeType; } });\r\nObject.defineProperty(exports, \"NoiseNodeType\", { enumerable: true, get: function () { return NodeType_1.NoiseNodeType; } });\r\nObject.defineProperty(exports, \"PoolNodeType\", { enumerable: true, get: function () { return NodeType_1.PoolNodeType; } });\r\nconst EvolveOptions_1 = require(\"../src/interfaces/EvolveOptions\");\r\nObject.defineProperty(exports, \"EvolveOptions\", { enumerable: true, get: function () { return EvolveOptions_1.EvolveOptions; } });\r\nconst TrainOptions_1 = require(\"../src/interfaces/TrainOptions\");\r\nObject.defineProperty(exports, \"TrainOptions\", { enumerable: true, get: function () { return TrainOptions_1.TrainOptions; } });\r\nconst Loss_1 = require(\"../src/methods/Loss\");\r\nObject.defineProperty(exports, \"ALL_LOSSES\", { enumerable: true, get: function () { return Loss_1.ALL_LOSSES; } });\r\nObject.defineProperty(exports, \"BinaryLoss\", { enumerable: true, get: function () { return Loss_1.BinaryLoss; } });\r\nObject.defineProperty(exports, \"HINGELoss\", { enumerable: true, get: function () { return Loss_1.HINGELoss; } });\r\nObject.defineProperty(exports, \"MAELoss\", { enumerable: true, get: function () { return Loss_1.MAELoss; } });\r\nObject.defineProperty(exports, \"MAPELoss\", { enumerable: true, get: function () { return Loss_1.MAPELoss; } });\r\nObject.defineProperty(exports, \"MBELoss\", { enumerable: true, get: function () { return Loss_1.MBELoss; } });\r\nObject.defineProperty(exports, \"MSELoss\", { enumerable: true, get: function () { return Loss_1.MSELoss; } });\r\nObject.defineProperty(exports, \"MSLELoss\", { enumerable: true, get: function () { return Loss_1.MSLELoss; } });\r\nObject.defineProperty(exports, \"WAPELoss\", { enumerable: true, get: function () { return Loss_1.WAPELoss; } });\r\nconst Mutation_1 = require(\"../src/methods/Mutation\");\r\nObject.defineProperty(exports, \"AddBackConnectionMutation\", { enumerable: true, get: function () { return Mutation_1.AddBackConnectionMutation; } });\r\nObject.defineProperty(exports, \"AddConnectionMutation\", { enumerable: true, get: function () { return Mutation_1.AddConnectionMutation; } });\r\nObject.defineProperty(exports, \"AddGateMutation\", { enumerable: true, get: function () { return Mutation_1.AddGateMutation; } });\r\nObject.defineProperty(exports, \"AddNodeMutation\", { enumerable: true, get: function () { return Mutation_1.AddNodeMutation; } });\r\nObject.defineProperty(exports, \"AddSelfConnectionMutation\", { enumerable: true, get: function () { return Mutation_1.AddSelfConnectionMutation; } });\r\nObject.defineProperty(exports, \"ALL_MUTATIONS\", { enumerable: true, get: function () { return Mutation_1.ALL_MUTATIONS; } });\r\nObject.defineProperty(exports, \"FEEDFORWARD_MUTATIONS\", { enumerable: true, get: function () { return Mutation_1.FEEDFORWARD_MUTATIONS; } });\r\nObject.defineProperty(exports, \"ModActivationMutation\", { enumerable: true, get: function () { return Mutation_1.ModActivationMutation; } });\r\nObject.defineProperty(exports, \"ModBiasMutation\", { enumerable: true, get: function () { return Mutation_1.ModBiasMutation; } });\r\nObject.defineProperty(exports, \"ModWeightMutation\", { enumerable: true, get: function () { return Mutation_1.ModWeightMutation; } });\r\nObject.defineProperty(exports, \"Mutation\", { enumerable: true, get: function () { return Mutation_1.Mutation; } });\r\nObject.defineProperty(exports, \"NO_STRUCTURE_MUTATIONS\", { enumerable: true, get: function () { return Mutation_1.NO_STRUCTURE_MUTATIONS; } });\r\nObject.defineProperty(exports, \"ONLY_STRUCTURE\", { enumerable: true, get: function () { return Mutation_1.ONLY_STRUCTURE; } });\r\nObject.defineProperty(exports, \"SubBackConnectionMutation\", { enumerable: true, get: function () { return Mutation_1.SubBackConnectionMutation; } });\r\nObject.defineProperty(exports, \"SubConnectionMutation\", { enumerable: true, get: function () { return Mutation_1.SubConnectionMutation; } });\r\nObject.defineProperty(exports, \"SubGateMutation\", { enumerable: true, get: function () { return Mutation_1.SubGateMutation; } });\r\nObject.defineProperty(exports, \"SubNodeMutation\", { enumerable: true, get: function () { return Mutation_1.SubNodeMutation; } });\r\nObject.defineProperty(exports, \"SubSelfConnectionMutation\", { enumerable: true, get: function () { return Mutation_1.SubSelfConnectionMutation; } });\r\nObject.defineProperty(exports, \"SwapNodesMutation\", { enumerable: true, get: function () { return Mutation_1.SwapNodesMutation; } });\r\nconst Rate_1 = require(\"../src/methods/Rate\");\r\nObject.defineProperty(exports, \"ExponentialRate\", { enumerable: true, get: function () { return Rate_1.ExponentialRate; } });\r\nObject.defineProperty(exports, \"FixedRate\", { enumerable: true, get: function () { return Rate_1.FixedRate; } });\r\nObject.defineProperty(exports, \"InverseRate\", { enumerable: true, get: function () { return Rate_1.InverseRate; } });\r\nObject.defineProperty(exports, \"Rate\", { enumerable: true, get: function () { return Rate_1.Rate; } });\r\nObject.defineProperty(exports, \"StepRate\", { enumerable: true, get: function () { return Rate_1.StepRate; } });\r\nconst Selection_1 = require(\"../src/methods/Selection\");\r\nObject.defineProperty(exports, \"FitnessProportionateSelection\", { enumerable: true, get: function () { return Selection_1.FitnessProportionateSelection; } });\r\nObject.defineProperty(exports, \"PowerSelection\", { enumerable: true, get: function () { return Selection_1.PowerSelection; } });\r\nObject.defineProperty(exports, \"Selection\", { enumerable: true, get: function () { return Selection_1.Selection; } });\r\nObject.defineProperty(exports, \"TournamentSelection\", { enumerable: true, get: function () { return Selection_1.TournamentSelection; } });\r\nconst Utils_1 = require(\"../src/utils/Utils\");\r\nObject.defineProperty(exports, \"avg\", { enumerable: true, get: function () { return Utils_1.avg; } });\r\nObject.defineProperty(exports, \"generateGaussian\", { enumerable: true, get: function () { return Utils_1.generateGaussian; } });\r\nObject.defineProperty(exports, \"max\", { enumerable: true, get: function () { return Utils_1.max; } });\r\nObject.defineProperty(exports, \"maxValueIndex\", { enumerable: true, get: function () { return Utils_1.maxValueIndex; } });\r\nObject.defineProperty(exports, \"min\", { enumerable: true, get: function () { return Utils_1.min; } });\r\nObject.defineProperty(exports, \"minValueIndex\", { enumerable: true, get: function () { return Utils_1.minValueIndex; } });\r\nObject.defineProperty(exports, \"pickRandom\", { enumerable: true, get: function () { return Utils_1.pickRandom; } });\r\nObject.defineProperty(exports, \"randBoolean\", { enumerable: true, get: function () { return Utils_1.randBoolean; } });\r\nObject.defineProperty(exports, \"randDouble\", { enumerable: true, get: function () { return Utils_1.randDouble; } });\r\nObject.defineProperty(exports, \"randInt\", { enumerable: true, get: function () { return Utils_1.randInt; } });\r\nObject.defineProperty(exports, \"removeFromArray\", { enumerable: true, get: function () { return Utils_1.removeFromArray; } });\r\nObject.defineProperty(exports, \"shuffle\", { enumerable: true, get: function () { return Utils_1.shuffle; } });\r\nObject.defineProperty(exports, \"sum\", { enumerable: true, get: function () { return Utils_1.sum; } });\r\n"]}